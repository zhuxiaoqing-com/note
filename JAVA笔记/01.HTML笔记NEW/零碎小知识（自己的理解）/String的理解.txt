String的常量池
    String的常量池在1.7以前在方法区里面，JDK1.7把常量池移到了堆内存里面
String常量池里面存的到底在引用还是对象
    常量池在1.6是将常量池放在了永久代中，在1.7将其移到了堆中
    存的是引用，并不是对象
String的intern方法1.6和1.7的区别 
   现在有这样一个疑问：
    1.6下：intern()方法会把首次遇到的字符串实例复制到永久代中，返回永久代中这个字符串实例的引用。而由StringBuilder创建的实例在Java堆中，必然不是同一个引用。返回false.
    1.7下：intern()不会复制实例，只是在常量池中记录首次出现的实力引用。所以intern()返回的引用和StringBuilder创建的字符串实例是同一个。 s2为什么会返回false呢?因为“java”这个字符串在执行StringBuilder.toString()前就出现过，已经有他的引用了。所以不是同一个对象。
    还有这样一段话：String常量池里面存储的都是String的引用！
    那么JDK1.6的intern()的方法的描述是不是和这段话矛盾了呢？一个是将对象复制到常量池中，一个是存储的是String的引用，
    而且JDK1.6以前常量池是在永久代（方法区）里面的把。方法区里面可以存储对象吗？ 照这样来看，1.6对intern的描述应该是错误的，那么
    String的intern()在1.6以前到底是怎么实现的呢

    个人理解在JDK1.6及以前，是复制了一个String对象并将其引用存到了常量池中，1.7是直接将对象引用存放到了常量池中

    String通过intern()方法来减少String对象的创建。
        你可以这样 String temp = (new String（"ss"）+ new String ("as")).intern.
        通过new来创建String对象，然后通过.intern来检索字符串常量池，如果检索到了一样的值，就把那个值的地址赋给temp，没有检索到的话就将这个对象放入到.intern.
        intern要慎用！因为滥用intern的话，会使常量池内存无限增大，然后超过常量池的空间就会抛出异常。
            而且intern用的多了，会使常量池里面的数据无限增多，使其在使用""来创建String对象的时候，会花费大量时间在搜索常量池里面！
