1.JAVA的命名规范
	**包 全部小写-xx.xx.xx
	**类：首字母大写，每个单词首字母都要大写
	**方法：首字母小写，之后每个单词首字母都要大写
	**变量：首字母小写,之后每个单词首字母都要大写

	这些命名还有一种方式
	**使用汉语拼音命名
	**不能把汉语拼音和英文字母混合使用

	*命名的最基本的规则：看到名字知道是什么含义

	*代码需要有缩进

2.debug的调试模式（断点调试模式）
    F5：跳入方法
    F6：向下逐行调试
    F7：跳出方法
    F8：直接跳转到下一个断点

	*使用这种模式，调试程序（看到程序里面数据的变化）

	*使用debug第一步需要设置一个断点（让程序运行停止在这一行）
		-显示出来行号
		-双击行号左边，出现一个圆点，表示设置了一个断点
	*使用debug as方式，运行程序
		-提示是否进入调试界面，yes
		-在断点那里，有一个绿色条，表示程序定制在这一行，没有向下运行
	*可以让程序向下运行
         
		-使用step over 快捷键是F6（单步执行）
		-resume 快捷键F8：表示调试结束，直接向下运行
			**比如当前的断点之后还有断点，跳到下一个断点
			**如果当前断点后面没有断点，程序直接运行结束

	*debug另外一个用途
		**查看程序的源代码
		**F7 step into：进入到方法
		**step return：返回

3.junit的使用
	*单元测试
	*测试对象是一个类中的方法
	*juint不是javase的一部分，想要使用导入jar包
		**但是，在myeclipse中自带junit的jar包

	*首先junit版本3.x4.x
		*单元测试方法时候，方法命名规则 public void 方法名(){}

	*使用注解方式运行测试方法，写在方法的上面
		** @Test :表示方法进行单元测试

	---要运行类中的多个测试方法，点击类中的其他位置

	** @Test :表示方法进行单元测试
	** @Ignore:在每个方法执行运行
	** @After:在每个方法之后运行

	**断言（了解）
		**Assert.assertEquals("测试期望的值","方法运行的实际的值");

4.泛型
	**jdk5.0出现的安全机制

	好处:
		1.将运行期间的问题ClassCastExcption转到了编译时期；
		2.避免了强制转换的麻烦；

	什么时候用：
		当操作的引用数据类型不确定的时候，就用<>.将要操作的引用数据类型传入即可
		其实<>就是一个用于接收具体引用数据类型的参数范围。

	泛型的擦除：
		运行时，会将泛型去掉，生成的class文件中是不带有泛型的，这个称之为泛型的擦除
		为什么要擦除呢？因为为了兼容运行的类加载器
	
	泛型的补偿：在运行时，通过获取元素的类型进行转换动作。不用使用者在强制转换了

5.枚举
	需要在一定范围内取值，这个值只能是这个范围内中的任意一个

	 创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类
	 （java.lang.Enum 是一个抽象类）。枚举类型符合通用模式 
	 Class Enum<E extends Enum<E>>，而 E 表示枚举类型的名称。
	 枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal)
	 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了
	 此设置被创建的顺序。

	    可以把 enum 看成是一个普通的 class，它们都可以定义一些属性和方法，
	    不同之处是：enum 不能使用 extends 关键字继承其他类，
	    因为 enum 已经继承了 java.lang.Enum（java是单一继承）。

	*使用一个关键字 enum
	**enum dd{
	RED,GREEN,GRAN;
	}  类

	枚举很像单例设计模式，每一个RED都是一个dd的实例；

	**valueof(String name)转换枚举对象  返回一个枚举对象
	**values() 获得所有枚举对象的数组

6.静态导入
	*可以在代码里面，直接使用静态导入方式，导入静态方法或者常量
	*import static xx.xx.xx
	*import static java.lang.System.out;
	 这样就可以直接使用out.println("hello");输出了
	 不用使用System.out.println("hello");

7.自动拆装箱
	装箱：Integer m = Integer.valueOf(127);
	拆箱：int a = m.intValue(Integer类);
	
	①无论如何，Integer与new Integer不会相等。不会经历拆箱过程，i3的引用指向堆，
		而i4指向专门存放他的内存（常量池），他们的内存地址不一样，所以为false
	②两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false
		java在编译Integer i2 = 128的时候,被翻译成-> Integer i2 = Integer.valueOf(128);
		而valueOf()函数会对-128到127之间的数进行缓存
	③两个都是new出来的,都为false
	④int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比

8.可变参数
	*可变参数可以应用在什么场景:
		如果实现多个方法，这些方法里面的逻辑基本相同，唯一不同的是传递的参数的个数，可以使用可变参数

	*可变参数的定义方法 数据类型...数组的名称
	*理解为一个数组，这个数组存储过来的参数
		void add(int a,int...b){}

	**一个方法最多只能有一个可变参数
	**可变参数必须是最后一个参数
	**可变参数只能出现在方法的形参中，局部变量或属性是不能使用可变参数的

9.反射：JAVA反射机制是在运行状态中，对于任意一个类（class文件），都能够知道这个类的所有属性和方法；
	对于任意一个对象，都能够调用它的任意一个方法和属性；
	这种动态获取信息以及动态调用对象的方法的功能称为java语言的反射机制

	动态获取类中的信息，就是java反射。
	可以理解为对类的解剖

怎么获取字节码对象

方式一 通过Object类中的getClass()方法
	想要通过这种方法，必须明确具体的类，并创建对象。

方式二 任何数据都有一个静态的属性.class来获取其对应的class对象
	相对简单，但还是要明确用到类中的静态成员

方式三 只要通过给定的类的字符串名称就可以获取该类，更为扩展。
	使用Class类中forName();方法

