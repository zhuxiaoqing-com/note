Mysql 中的行级锁，表级锁，页级锁

    在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。

    在数据库的锁机制中介绍过，在 DBMS 中，可以按照锁的粒度把数据库锁分为 
    行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。

行级锁
    行级锁是 Mysql 中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，
    但加锁的开销也最大。行级锁分为 共享锁 和 排他锁。
    特点： 开销大，加锁慢。会出现死锁; 锁定粒度最小，发生锁冲突的概率最低，并发度也最高

表级锁
    表级锁是 MySql 中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 Mysql 引擎支持
    最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。
    特点： 开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。


页级锁

    页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，
    一次锁定相邻的一组记录。BDB支持页级锁
    特点： 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般


    MySQL常用存储引擎的锁机制

    MyISAM 和 MEMORY 采用表级锁(table-level locking)

    BDB 采用页面锁(page-level locking)或表级锁，默认为 页面锁

    InnoDB 支持行级锁(row-level locking)和表级锁,默认为 行级锁


Innodb中的行锁与表锁
    前面提到过，在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？

    InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 mysql 和 oracle 不同，后者是通过在数据块中相应数据行加锁来实现的。
    InnoDB 这种行锁实现特点意味着： 只有通过索引条件检索数据， InnoDB 才使用行级锁，否则 InnoDB 将使用表锁！

  在实际应用中，要特别注意 InnoDB 行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能

    1.在不通过索引条件查询的时候， InnoDB 确实使用的是表锁，而不是行锁
    2.由于 Mysql 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。
        应用设计的使用要注意这一点。 可以认为是通过查询的时候的相关的索引来加锁的。 因为这个索引已经加过锁了

    3.即便在条件中使用了索引字段,但是否使用索引来检索数据是由 MySQL 通过判断不同 执行计划的代价来决定的,如果 MySQL 认为全表扫 效率更高,
    比如对一些很小的表,它 就不会使用索引,这种情况下 InnoDB 将使用表锁,而不是行锁。因此,在分析锁冲突时, 别忘了检查 SQL 的执行计划,
    以确认是否真正使用了索引。


行级锁与死锁

    MyISAM 中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。
    而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。

    在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，
    MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 
    在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。

    当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。
    发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。

    
有多种方法可以避免死锁，这里只介绍常见的三种

    1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。

    2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；

    3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；



-------哈哈---------------------------------------------------------------------------------------------------------------------


行锁分为三种情形：

    Record lock ：对索引项加锁，即锁定一条记录。

    Gap lock：对索引项之间的‘间隙’、对第一条记录前的间隙或最后一条记录后的间隙加锁，即锁定一个范围的记录，不包含记录本身

    Next-key Lock：锁定一个范围的记录并包含记录本身（上面两者的结合）。

    Next-Key Lock是行锁与间隙锁的组合，这样，当InnoDB扫描索引记录的时候，会首先对选中的索引记录加上行锁（Record Lock），
    再对索引记录两边的间隙加上间隙锁（Gap Lock）。如果一个间隙被事务T1加了锁，其它事务是不能在这个间隙插入记录的。


InnoDB行锁是通过给索引项加锁实现的，如果没有索引，InnoDB会通过隐藏的聚簇索引来对记录加锁。

也就是说：如果不通过索引条件检索数据，那么InnoDB将对表中所有数据加锁，实际效果跟表锁一样。



当一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之如果请求不兼容，则该事务就等待锁释放。


共享锁（S）
排他锁（X）

意向共享锁（IS）
意向排他锁（IX）



脏读
1. 使用排他锁线程可以对其锁定记录进行读取，读取的内容为当前事物的最新版本；而对于不使用排他锁的线程，同样是可以进行读取操作，
这种特性是一致性非锁定读。即对于同一条记录，数据库记录多个版本，在事物内的更新操作会反映到新版本中，而旧版本会提供给其他线程进行读取操作。

不可重复读
2. 使用排他锁线程可对其锁定记录进行写入操作；对于不使用排他锁的线程，对锁定记录的写操作是不允许的，请求会阻塞。

可重复读
3. 使用排他锁进程可对其锁定记录申请共享锁，但是申请共享锁之后，线程并不会释放原先的排他锁，因此该记录对外表现出排他锁的性质；
其他线程是不可对已锁定记录申请共享锁，请求会阻塞。

4. 使用排他锁进程可对其锁定记录申请排他锁（实际上并没有任何意义）；而其他进程是不可对锁定记录申请排他锁，申请会阻塞。




----------哈哈----------------------------------------------------------------------------------------------------


mysql锁机制分为表级锁和行级锁，本文就和大家分享一下我对mysql中行级锁中的共享锁与排他锁进行分享交流。

共享锁又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。

排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。

对于共享锁大家可能很好理解，就是多个事务只能读数据不能改数据，对于排他锁大家的理解可能就有些差别，我当初就犯了一个错误，
以为排他锁锁住一行数据后，其他事务就不能读取和修改该行数据，其实不是这样的。排他锁指的是一个事务在一行数据加上排他锁后，
其他事务不能再在其上加其他的锁。mysql InnoDB引擎默认的修改数据语句，update,delete,insert都会自动给涉及到的数据加上排他锁，
select语句默认不会加任何锁类型，如果加排他锁可以使用select ...for update语句，加共享锁可以使用select ... lock in share mode语句。
所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，
但可以直接通过select ...from...查询数据，因为普通查询没有任何锁机制。

共享锁(Share Lock)

    共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），
    直到已释放所有共享锁。

    如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获得共享锁的事务只能读数据，不能修改数据。

    用法

    SELECT ... LOCK  IN SHARE MODE;

    在查询语句后面增加 LOCK IN SHARE MODE，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，
    可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。


排他锁（eXclusive Lock）

    共享锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的锁，其它事务也不能对A做update，insert，delete操作，
    因为在innodb中这些操作默认加了排他锁，可以进行select 操作因为查询的时候是不加任何锁的。

    用法

    SELECT ... FOR UPDATE;

    在查询语句后面增加 FOR UPDATE，Mysql会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，
    可以成功申请排他锁，否则会被阻塞。



意向锁

    InnoDB还有两个表锁：

    意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁

    意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。

    意向锁是InnoDB自动加的，不需要用户干预。

    对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁（X）；对于一般的Select语句，InnoDB不会加任何锁，
    事务可以通过以下语句给显示加共享锁或排他锁。

    共享锁： SELECT ... LOCK IN SHARE MODE;

    排他锁： SELECT ... FOR UPDATE;



for update 排他锁
lock in share mode 共享锁


    锁的机制就是不能其他语句再给加锁，并不是不给读写
    而 读写改 会自动为其加锁
    select .. from 不会自动加锁，所以就没有 死锁
    但是 你 显示使用 for update 和  lock in share mode 的话就也会产生死锁了 因为你显示的要求加锁


行锁： 共享锁 lock in share mode  排它锁  for update

排他锁:

    记录锁  间隙锁gap lock   next-key 锁 


记录锁 : 其实很好理解，对表中的记录加锁，叫做记录锁，简称行锁。

间隙锁 gap lock ： 他们之间的空隙也就是间隙，而封锁他们之间距离的锁，叫做间隙锁。在RR事务下自动加
    间隙锁对 主键和 unique 索引是不会加的，因为你只是更新一个的话，但是如果你是范围的话就会加了，因为范围本来就是扫描。
        对于非唯一索引就会加间隙锁
    一个数据库有  id =  1,3,5,6,8,9
    比如 你操作了 id = 5 , 并加了间隙锁, 那么  3,5  5,6 
        之间是没法插入数据的  你插入 4 就阻塞  插入 7 可以
         如果给不存在的数据加了间隙锁，那么其区间是存在的id 与 无限大或小
         比如 你 delete id= 2, id=2 不存在，那么间隙锁就是 {无限小，3}, 在无限小和 3 之间不能插入 数据

         但是 3 本身还是没加锁，也就是说可以修改不能 插入
         间隙锁主要就是防止 insert into 语句

next-key 锁： gap lock + next -key

gap锁的目的，只要把握一点：就是让后续不能插入满足条件的新纪录，然后按照这个点，去考虑哪些地方需要加gap锁。


为什么组合五、组合六，也是RR隔离级别，却不需要加GAP锁呢？


首先，这是一个好问题。其次，回答这个问题，也很简单。
GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。而组合五，id是主键；
组合六，id是unique键，都能够保证唯一性。一个等值查询，最多只能返回一条记录，而且新的相同取值的记录，一定不会在新插入进来，
因此也就避免了GAP锁的使用。其实，针对此问题，还有一个更深入的问题：
如果组合五、组合六下，针对SQL：select * from t1 where id = 10 for update; 
第一次查询，没有找到满足查询条件的记录，那么GAP锁是否还能够省略？会加 gap 锁，因为不存在所以会加锁。




Read Uncommited
可以读取未提交记录。此隔离级别，不会使用，忽略。

Read Committed (RC)
快照读忽略，本文不考虑。

针对当前读，RC隔离级别保证对读取到的记录加锁 (记录锁)，存在幻读现象。

Repeatable Read (RR)
快照读忽略，本文不考虑。

针对当前读，RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)，不存在幻读现象。

Serializable
从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。

Serializable隔离级别下，读写冲突，因此并发度急剧下降，在MySQL/InnoDB下不建议使用。



使用主键的话，锁是锁主键的，如果你使用非主键的话锁会先锁非主键，然后锁住主键。


针对一条当前读的SQL语句，InnoDB与MySQL Server的交互，是一条一条进行的，因此，加锁也是一条一条进行的。先对一条满足条件的记录加锁，返回给MySQL Server，做一些DML操作；然后在读取下一条加锁，直至读取完毕。

加锁是一步一步的
  当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，
  并加锁 (current read)。待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。
  一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。
  同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。
  
  也就是说数据是一条一条获取的。获取来然后加锁 ，然后加锁成功后，将其更新。然后再查询下一条语句。直到没有满足条件的记录为止。


锁操作分为两个阶段：加锁阶段与解锁阶段，并且保证加锁阶段与解锁阶段不相交
    先一步一步加锁 ，加完 一起释放。



死锁。 加锁 针对于 事务来讲，一个事务中，锁共享的
   因为加锁是一条一条语句来的，所以可能你下一条要加的记录的锁，被别的事务已反向的方式加锁，加上了。而别的事务也想要你的加锁的语句的锁。
   死锁就产生了
   
   死锁有两种：一种是  sesssion1 有两条语句 delete update  session2 有两条语句 update delete 。
            session1 delete 获取了锁。 session2 update 获取了锁。 
            session1 update 的锁在 session2 那里，卡住了。
            session2 delete 的锁在 session1 那里，卡住了。
          
       还有一种是 sesssion1 有一条语句 update  session2 有一条记录 update
       都是有多个满足的条件， 但是 where 查询是相反的。那么久一定会导致死锁。因为 session1 将 sesssion2 符合条件的最后一条语句锁住了。
       而 sesssion2 将 session1 符合条件的第一条语句锁住了。 那么久一定会卡死。


对于没有使用索引来进行 update 等操作时，会锁全表。
但是用的不是表锁。
    由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。从图中可以看到，满足删除条件的记录有两条，
    但是，聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。

    在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁
    (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。

 针对   read committed
    若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，
    都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，
    但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。


针对 Repeatable Read 也做了优化

优化就是 semi-consistent
    semi-consistent read只会发生在read committed 和 current read 隔离级别下，或者是参数innodb_locks_unsafe_for_binlog被设置为true。
            一个update语句，如果读到一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，由MySQL上层判断此版本是否满足update
            的where条件。若满足(需要更新)，则MySQL会重新发起一次读操作，此时会读取行的最新版本(并加锁)。
    try_semi_consistent_read(1); 开启 semi-consistent read
    try_semi_consistent_read(0); 关闭 semi-consistent read

    Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，
    杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，
    但是semi-consistent read本身也会带来其他问题，不建议使用。



==============================================

快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析) 在 Serializable 下 读不加锁就不再成立，所有的读操作，都是当前读。
select * from table where ?;
当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。
select * from table where ? lock in share mode;
select * from table where ? for update;
insert into table values (…);
update table set ? where ?;
delete from table where ?;
所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。
其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。

 

==============================================


但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。


MVCC ：MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议
        读不加锁，读写不冲突。
        在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本
        (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，
        保证其他事务不会再并发修改这条记录。

Lock-Based CC：MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议

        Lock-Based CC 和 MVCC 相对






事务机制归属 innoDB  事务本质就是根据不同的级别对相同的语句做不同的的加锁策略’

innoDB 事务非常安全 批量添加效率低，因为有大量锁机制，所以低
        有外键机制
        使用行锁。
         开销大，加锁慢。会出现死锁; 锁定粒度最小，发生锁冲突的概率最低，并发度也最高
         非常适合高并发。在高并发下，运行的很快。适合做大量的 增删改 操作。

MyISAM 应该是适合大量大读取操作吧，使用的是表锁。基本不支持并发 增删改。不加锁不安全。加锁就锁表 一并发就锁表。导致 大量的 语句堵塞，基本也就是没有并发。都是串行。不会产生死锁。

        






============================================================================================










1、查询是否锁表 show OPEN TABLES where In_use > 0;
 
2、查询进程
    show processlist   查询到相对应的进程===然后 kill    id
 
补充：
查看正在锁的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS; 
 
查看等待锁的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS; 





意向锁  IS IX  SIX 

        SIX 表示行里面既有 S 锁 也有 X锁

    数据库引擎使用意向锁来保护锁层次结构的底层资源，以防止其他事务对自己锁住的资源造成伤害，提高锁冲突检测性能。例如，当读取表里的页面时，
    在请求页共享锁（S锁）之前，事务在表级请求共享意向锁。这样可以防止其他事务随后在表上获取排他锁（X锁），修改整个表格。意向锁可以提高性能，
    因为数据库引擎仅在表级检查意向锁，确定事务是否能安全地获取该表上的锁，而不需要检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。

    在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。

    一个事务想要申请锁的话，必须先申请相应的事务锁。
 
    IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突
    行级别的X和S按照普通的共享、排他规则即可。所以之前的示例中第2步不会冲突，只要写操作不是同一行，就不会发生冲突。


意向锁是在添加行锁之前添加。
    当再向一个表添加表级X锁的时候
    如果没有意向锁的话，则需要遍历所有整个表判断是否有行锁的存在，以免发生冲突
    如果有了意向锁，只需要判断该意向锁与即将添加的表级锁是否兼容即可。
    因为意向锁的存在代表了，有行级锁的存在或者即将有行级锁的存在。因而无需遍历整个表，即可获取结果

意向锁的主要功能就是 当一个语句要在表上添加表锁的时候，直接查看有没有相应的排斥的意向锁就好了。不用遍历整个表 查看有没有意向锁
    意向锁，如果有事务需要请求表锁，就不需要进行遍历是否有行锁，而是直接查看该表是否有对应的意向锁


    百度百科上的 意向锁的作用：
            引进意向锁是为了提高封锁子系统的效率。该封锁子系统支持多种封锁粒度。
                原因是：
                    在多粒度封锁方法中一个数据对象可能以两种方式加锁 D 显式封锁和隐式封锁。
                    因此系统在对某一数据对象加锁时不仅要检查该数据对象上有无（显式和隐式）封锁与之冲突，
                    还要检查其所有上级结点和所有下级结点，看申请的封锁是否与这些结点上的（显式和隐式）封锁冲突，
                    显然，这样的检查方法效率很低。为此引进了意向锁。意向锁的含义是：对任一结点加锁时，必须先对它的上层结点加意向锁。
                    例如事务 T 要对某个元组加 X 锁，则首先要对关系和数据库加 ix 锁。换言之，对关系和数据库加 ix 锁，
                    表示它的后裔结点 D 某个元组拟（意向）加 X 锁。引进意向锁后，系统对某一数据对象加锁时不必逐个检查与下一级结点的封锁冲突了。
                    例如，事务 T 要对关系 R 加 X 锁时，系统只要检查根结点数据库和 R 本身是否已加了不相容的锁（如发现已经加了 ix ，则与 X 冲突），
                    而不再需要搜索和检查 R 中的每一个元组是否加了 X 锁或 S 锁。




MySQL的InnoDB引擎强烈建议使用自增主键的原因
          聚簇索引是按存放的物理位置为顺序的  聚簇索引会移动数据将其按某种规则排列放置，如果你每次 主键 都是随机的，那么就要频繁移动数据，
          来使数据符合聚簇索引的排放规则。
    1)InnoDB使用聚集索引，数据记录本身被存于主索引的叶子节点上，这就要求同一个叶子节点内的各条数据记录按主键顺序存放，因此每当一条新的记录插入时，
    MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子，则开辟一个新的页（节点）如果表使用自增主键，那么每次插入新的记录时，
    记录就会顺序添加到当前索引节点后续位置，当一页写满，就会自动开辟一个新的页。这样就就会形成一个紧凑的索引结构，近似顺序填满，
    由于每次插入时也不需要移动所有数据，因此效率很高，也不会增加很多额外的开销维护索引如果使用非自增主键，由于每次插入主键的值近乎于随机，
    因此每次新纪录都要被插到现有索引页的中间某个位置，此时MySQL不得不为了将新纪录插到合适位置而移动数据，甚至目标页面可能已经被写到磁盘而从缓存中清除，
    这增加了很多额外开销，同时频繁的移动，分页造成了大量的碎片，得到不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建并优化填充页面。

    2)由于MySQL从磁盘读取数据时一块一块来读取的，同时，根据局部性原理，MySQL引擎会选择预读一部分和你当前读数据所在内存相邻的数据块，
    这个时候这些相邻数据块的数据已经存在于内存中。由于数据库大部分是查询操作，这个时候，如果主键是自增的话，数据存储都是紧凑地存储在一起的，
    那么对于局部性原理利用和避免过多地I/O操作都有着巨大的促进作用




    

读 和  写  一起申请 锁的话。写会先获得。 MySQL 认为 写 比 读 重要


    因为MySQL认为写请求一般比读请求要重要。这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，
    因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。




事务的四大特性
    原子性、一致性、隔离性、持久性

    原子性A：事务中所有的操作是不可再分割的原子单位。事务中所有操作要么全部执行成功要么全部执行失败
    一致性C：事务执行成功后，数据库状态和其他业务规则保持一致，如转账业务，无论事务执行成功与否，参与转账的两个账号的余额之和应该是不变的。
    隔离性I：隔离性是指在并发操作中，不同事物之间应该是隔离开来的，使每个并发中的事务不会互相干扰;
    持久性D：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在
            数据库重启时，也必须保证通过某种机制恢复数据。

























