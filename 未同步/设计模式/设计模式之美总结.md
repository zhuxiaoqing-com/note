

## 1、设计原则

###     SOLID原则-SRP单一职责原则：

```
        一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计力度小、功能单一的类。
        单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。
```

### SOLID原则-OCP开闭原则

```
添加一个新的功能应该是，在已有代码基础上扩展代码(新增模块、类、方法等)，而非修改已有代码(修改模块、类、方法等)
```

### SOLID原则-LSP里式替换原则

```
子类对象能够替换程序中父类对象出现的任何地方，并且保证原来的程序的逻辑行为不变及正确性不被破坏。

里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。
理解里式替换原则，最核心的就是理解 "按照协议来设计" 这几个字。
父类定义了函数的 "约定"(或者叫协议)，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的"约定"。
这里的约定包括：函数声明要实现的功能：
	对输入、输出、异常的约定;甚至包括注释中所罗列的任何特殊说明。
```

### SOLID原则-ISP接口隔离原则

```
客户端不应该强迫依赖它不需要的接口。其中的"客户端"可以理解为接口的调用者或者使用者。
用来保证接口责任单一。
```

接口隔离原则和单一职责原则的区别

```
单一职责原则针对的是模块、类、接口的设计。
接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接的判定。
如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。

这里的接口隔离 比如 Service implements View, Updater;
这里输出就由 view 来做;
更新就由updater 接口来做;
```

### SOLID原则-DIP依赖反转原则

```
高层模块不要依赖底层模块。
高层模块和底层模块应该通过抽象来互相依赖。
除此之外，抽象不需要依赖实现细节，具体实现细节依赖抽象。
```

### KISS原则

```
Keep It Simple and Stupid;

尽量保持简单
```

### YAGNI原则

```
You Ain't Gonna Need It
你不会需要它。

不要去设计当前用不到的功能;不要去编写当前用不到的代码。
实际上，这条原则的核心思想就是：不要过度设计
```

### LOD原则

```
迪米特原则：高内聚，低耦合; 最少知道原则

不该有直接依赖关系的类之间，不要有依赖;
有依赖关系的类之间，尽量只依赖必要的接口(也就是定义中的"有限知识")
```

1、如何理解"高内聚，低耦合"？

```
"高内聚，低耦合"是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。

"高内聚"用来指导类本身的设计，"松耦合"用来指导类与类之间依赖关系的设计。

所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。
相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。
所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。
即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。
```

2、如何理解"迪米特法则"

```
不该有直接依赖关系的类之间，不要有依赖;
有依赖关系的类之间，尽量职以来必要的接口。
迪米特法则是希望减少类之间的耦合，让类越独立越好。
每个类都应该少了解系统的其他部分。
一旦发生变化，需要了解这一变化的类就会比较少。
```



## 2、设计模式

### 一、创建型设计模式

```
创建型设计模式包括：单例模式、工厂模式、建造者模式、原型模式。
它主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。
```

#### 1、单例模式

```
单例模式用来创建全局唯一的对象。
一个类只允许创建一个对象(或者叫实例)，那这个类就是一个单例类，这种设计模式叫做单例模式。

单例有几种经典的实现方式,它们分别是：饿汉式、懒汉式、双重检测、静态内部类、枚举。
```

```
尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式(anti-pattern),并不推荐使用，主要的理由有以下几点：

单例对 OOP 特性的支持不友好
单例会隐藏类之间的依赖关系
单例对代码的扩展性不友好
单例对代码的可测试性不友好
单例不支持有参数的构造函数
```

```
那有什么替代单例的解决方案呢？如果要完全解决这些问题，我们可能要从根上寻找其他方式来实现全局唯一类。比如，通过工厂模式、IOC容器来保证全局唯一性。
```

```
有人把单例当做反模式，主张杜绝在项目中使用。
我个人觉得这有些极端。
模式本身没有对错，关键看你怎么用。
如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。
对于一些全局类，我们在其他地方 new 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。
```

#### 2、工厂模式

```
工厂模式包括简单工厂、工厂方法、抽象工厂这3种细分模式。
其中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。
```

```
工厂模式用来创建不同但是相关类型的对象(继承同一父类或接口的一组子类)，由给定的参数来决定哪种类型的对象。
实际上，如果创建对象的逻辑并不复杂，那我们直接通过 new 来创建对象就可以了，不需要使用工厂模式。
当创建逻辑比较复杂，是一个"大工程"的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。
```

```
当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。
当每个对象创建逻辑都比较复杂的时候，为了避免设计一个多于庞大的工厂类，我们推荐使用工厂方法模式，将创建逻辑拆分的更细，每个对象的创建逻辑独立到各自的工厂类中。
```

```
详细点说，工厂模式的作用有下面4个，这也是判断要不要使用工厂模式最本质的参考标准。

封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。

代码复用：创建代码抽离到独立的工厂类之后可以复用。

隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。

控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。
```

```
除此之外，我们还讲了工厂模式一个非常经典的应用场景：
依赖注入框架，比如 Spring IOC、Google Guice, 它用来集中创建、组装、管理对象，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。
DI框架已经成为了我们平时开发的必备框架。
```

#### 3、建造者模式

```
建造者模式用来创建复杂对象，可以通过设置不同的可选参数，"定制化"的创建不同的对象。
建造者的原理和实现比较简单，重点是掌握应用场景，避免过度使用。

如果一个类中有很多属性，为了避免构造函数的参数过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。
但是，如果存在下面一个情况中的任意一种，我们就要考虑使用建造者模式了。
```

```
1、
我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。
如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。
如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。
```

```
2、
如果类的属性之间有一定的依赖关系或者约束关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。
```

```
如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露set()方法。构造函数配合set()方法来设置属性值的方式就不适用了。
```

#### 4、原型模式

```
如果对象的创建成本比较大，而同一个类的不同对象之间差别不大(大部分字段都相同)，在这种情况下，我们可以利用对已有对象(原型)进行复制(或者拷贝)的方式，来创建新对象，已达到节省创建时间的目的。
这种基于原型来创建对象的方式就叫做原型模式。
```

```
原型模式有两种实现方法，深拷贝和浅拷贝。
浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归的复制引用对象，以及引用对象的引用对象...而深拷贝得到的是一份完完全全独立的对象。
所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。
```

```
如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。
除非操作非常耗时，比较推荐使用浅拷贝，否则，没有充分的理由，不要为了一点点的性能而使用浅拷贝。
```



### 二、结构型设计模式

```
结构性模式主要总结了一些类或对象组合在一起的经典结构，这些经典的接口可以解决特定应用场景的问题。
结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。
```



#### 1、代理模式

```
代理模式下载不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰者模式最大的不同。
一般情况下，我们让代理类和原始类实现同样的接口。
但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。
在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。
```

```
静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板模式的"重复"代码，增加了维护成本和开发成本。
对于静态代理存在的问题，我们可以通过动态代理来解决。
我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。
```

```
代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。
我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。
除此之外，代理模式还可以用在 RPC、缓存等应用场景中。
```



#### 2、桥接模式

```
桥接模式的代码实现非常简单，但是理解起来稍微有些难度，并且应用场景也比较局限，所以，相对来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以了，并不是我们学习的重点。
```

```
桥接模式有两种理解方式。
第一种理解方式是"将抽象和实现解耦，让它们能独立开发"。
这种理解方式比较特别，应用场景也不多。
另一种理解方式更加简单，等同于"组合优于继承"设计原则，这种理解方式更加通用，应用场景比较多。
不管是那种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。
```

```
对于第一种理解方式，弄懂定义中"抽象"和"实现"两个概念，是理解它的关键。
定义中的"抽象"，指的并非"抽象类"或"接口"，而是被抽象出来的一套"类库"，它只包含骨架代码，真正的业务逻辑需要委派给定义中的"实现"来完成。

而定义中的"实现"，也并非"接口的实现类"，而是一套独立的"类库"。
"抽象"和"实现"独立开发，通过对象之间的组合关系组装在一起。
```



#### 3、装饰者模式

```
装饰者模式主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。
这也是判断是否该用装饰器模式的一个重要的依据。
除此之外，装饰器模式还有一个特点，那就是对原始类嵌套使用多个装饰器。
为了满足这样的需求，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。
```



#### 4、适配器模式

```
代理模式、装饰器模式提供的都是跟原始类相同的接口，而适配器提供跟原始类不同的接口。
适配器模式是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。
适配器模式有两种实现方式：类适配器和对象适配器。
其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。
```

```
适配器模式是一种事后的补救策略，用来补救设计上的缺陷。
应用这种设计模式算是"无奈之举"。
如果在设计初期，我们就能规避接口不兼容的问题，那这种设计模式就无用武之地了。
在实际的开发中，什么情况下才会出现接口不兼容呢？
```

```
我总结了下面这5种场景：
封装有缺陷的接口设计
统一多个类的接口设计
替换依赖的外部系统
兼容老版本的接口
适配不同格式的数据
```

#### 5、门面模式

```
门面模式原理、实现都非常简单，应用场景比较明确。
它通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题。
```



#### 6、组合模式

```
组合模式跟我们之前讲的面向对象设计中的"组合关系(通过组合来组装两个类)"，完全是两码事。
这里讲的"组合模式"，主要是用来处理树形结构数据。
正因为其应用场景的特殊性，数据必须能表示树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。
```

```
组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。
其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。
组合模式，将一组对象组织成树形接口，将单个对象和组合对象都看作树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归的处理每个子树，依次简化代码实现。
```



#### 7、享元模式

```
所谓"享元"，顾名思义就是被共享的单元。
单元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。

具体来讲，当一个系统中存在着大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，已起到节省内存的目的。
实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分(字段)，提取出来设计成享元，让这些大量相似对象引用这些享元。
```



### 三、行为型设计模式

```
我们知道，创建型设计模式主要解决"对象的创建"问题，结构型设计模式主要解决"类或对象的组合问题"，那行为型设计模式主要解决的就是"类或对象之间的交互"问题。
行为型模式比较多，有11种，它们分别是：观察者模式、模板模式、策略模式、责任链模式、迭代器模式、状态模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。
```

#### 1、观察者模式

```
观察者模式将观察者和被观察者代码解耦。
观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质都是观察者模式。
```

```
不同的应用场景和需求下，这个模式也有截然不同的实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；
有进程内的实现方式，也有跨进程的实现方式。
同步阻塞是最经典的实现方式，主要是为了代码解耦;
异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率;
进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。
```

```
框架的作用有隐藏实现细节，降低开发难度，实现代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。
```



#### 2、模板模式

```
模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。
模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。
这里的"算法"，我们可以理解为广义上的"业务逻辑"，并不特指数据结构和算法中的"算法"。
这里的算法骨架就是"模板"，包含算法骨架的方法就是"模板方法"，这也是模板方法模式名字的由来。
```

```
模板模式有两大作用：复用和扩展。
其中复用指的是，所有子类可以复用父类中提供的模板方法的代码。
扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。
```

```
除此之外，我们还讲到回调。
它跟模板模式具有相同的作用：
代码复用和扩展。
在一些框架、类库、组件等的设计中经常会用到，比如 Jdbc Template 就是用了回调。
```

```
相对于普通的函数调用，回调是一种双向调用关系。
A类事先注册某个函数F 到 B类，A类在调用B类的P函数的时候，B类反过来调用A类注册给它的F函数。
这里的F函数就是"回调函数"。
A调用B，B返回来又调用A，这种调用机制就叫作"回调"。
```

```
回调可以细分为同步回调和异步回调。
从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像是观察者模式。
回调很模板的区别，更多的是在代码实现上，而非应用场景上。
回调基于组合关系来实现，模板模式基于继承关系来实现。
回调比模板模式更加灵活。
```

#### 3、策略模式

```
策略模式定义一组算法类，将每个算法分别封装起来，让它们可以互相替换。
策略模式可以使算法的变化独立于使用它们的客户端(这里的客户端代指使用算法的代码)。 
策略模式可以用来解耦策略的定义、创建、使用。
实际上，一个完整的策略模式就是由这三个部分组成的。
```

```
策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。
策略的创建由工厂类来完成，封装策略创建的细节。
策略模式包含一组策略可选，客户端代码选择使用哪个策略，有两种确定方法：
编译时静态确定和运行时动态确定。
其中，"运行时动态确定"才是策略模式最典型的应用场景。
```

```
在实际的项目开发中，策略模式也比较常用。
最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支来判断。
不过，它的作用还不止如此。
它也可以像模板模式那样，提供框架的扩展点等等。
实际上，策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。
除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险。
```

#### 4、职责链模式

```
在职责链模式中，多个处理器依次处理同一个请求。
一个请求先经过A处理器处理，然后再把请求传递给B处理器，B处理器处理完后再传递给C处理器，以此类推，形成一个链条。
链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。
```

```
在 GoF 的定义中，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理器了。
当然，在实际的开发中，也存在对这个模式的变体，那就是请求不会中途终止传递，而是会被所有的处理器都处理一遍。
```

```
职责链模式常用在框架开发中，用来实现过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤、拦截功能。
这也体现了之前讲到的对扩展开放，对修改关闭的设计原则。
```



#### 5、迭代器模式

```
迭代器模式也叫游标模式，它用来遍历集合对象。
这里说的"集合对象"，我们也可以叫"容器" "聚合对象"，实际上就是一组对象的对象，比如，数组、链表、数、图、跳表。
迭代器模式主要作用是解耦容器代码和遍历代码。
大部分编程语言都提供了现成的迭代器可以使用，我们不需要从零开始开发。
```

#### 6、状态模式

```
状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。
状态机又叫有限状态机，它由三个部分组成：状态、事件、动作。
其中，事件也称为转移条件。
事件触发状态的转移及动作的执行。
不过，动作不是必须的，也可能只转移状态，不执行任何状态。
```

```
针对状态机，我们总结了三种实现方式。
```

```
第一种实现方式叫分支逻辑法。
利用if-else或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样的直译成代码。
对于简单的状态机来说，这种实现方式最简单、最直接，是首选。
```

```
第二种实现方式叫查表法。
对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。
通过二维数组来表示状态转移图，能够极大的提高代码的可读性和可维护性。
```

```
第三种实现方式就是利用状态模式。
对于状态并不多、状态转移也比较简单,但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种方式。
```



#### 7、访问者模式

```
访问者模式实现 double Dispatch。
```

#### 8、备忘录模式

```
备忘录模式就是快照模式
```

#### 9、命令模式

```
落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。
我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。
借助命令模式，我们将函数封装成对象，这样就可以实现吧函数像对对象一样使用。
```

```
命令模式的主要作用和应用场景，是用来控制命令的执行，
比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等，这才是命令模式能发挥独一无二作用的地方。
```



#### 10、解释器模式

```
用来实现根据语法规则解读"句子"的解释器。
```

#### 11、中介模式

```
中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系(或者说依赖关系)从多对多(网状关系)转换为一对多(星状关系)。
原来一个对象要跟n哥对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。
```

















