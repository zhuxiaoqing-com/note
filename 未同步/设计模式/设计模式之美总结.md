

## 1、设计原则

###     SOLID原则-SRP单一职责原则：

```
        一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计力度小、功能单一的类。
        单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。
```

### SOLID原则-OCP开闭原则

```
添加一个新的功能应该是，在已有代码基础上扩展代码(新增模块、类、方法等)，而非修改已有代码(修改模块、类、方法等)
```

### SOLID原则-LSP里式替换原则

```
子类对象能够替换程序中父类对象出现的任何地方，并且保证原来的程序的逻辑行为不变及正确性不被破坏。

里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。
理解里式替换原则，最核心的就是理解 "按照协议来设计" 这几个字。
父类定义了函数的 "约定"(或者叫协议)，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的"约定"。
这里的约定包括：函数声明要实现的功能：
	对输入、输出、异常的约定;甚至包括注释中所罗列的任何特殊说明。
```

### SOLID原则-ISP接口隔离原则

```
客户端不应该强迫依赖它不需要的接口。其中的"客户端"可以理解为接口的调用者或者使用者。
用来保证接口责任单一。
```

接口隔离原则和单一职责原则的区别

```
单一职责原则针对的是模块、类、接口的设计。
接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接的判定。
如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。

这里的接口隔离 比如 Service implements View, Updater;
这里输出就由 view 来做;
更新就由updater 接口来做;
```

### SOLID原则-DIP依赖反转原则

```
高层模块不要依赖底层模块。
高层模块和底层模块应该通过抽象来互相依赖。
除此之外，抽象不需要依赖实现细节，具体实现细节依赖抽象。
```

### KISS原则

```
Keep It Simple and Stupid;

尽量保持简单
```

### YAGNI原则

```
You Ain't Gonna Need It
你不会需要它。

不要去设计当前用不到的功能;不要去编写当前用不到的代码。
实际上，这条原则的核心思想就是：不要过度设计
```

### LOD原则

```
迪米特原则：高内聚，低耦合; 最少知道原则

不该有直接依赖关系的类之间，不要有依赖;
有依赖关系的类之间，尽量只依赖必要的接口(也就是定义中的"有限知识")
```

1、如何理解"高内聚，低耦合"？

```
"高内聚，低耦合"是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。

"高内聚"用来指导类本身的设计，"松耦合"用来指导类与类之间依赖关系的设计。

所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。
相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。
所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。
即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。
```

2、如何理解"迪米特法则"

```
不该有直接依赖关系的类之间，不要有依赖;
有依赖关系的类之间，尽量职以来必要的接口。
迪米特法则是希望减少类之间的耦合，让类越独立越好。
每个类都应该少了解系统的其他部分。
一旦发生变化，需要了解这一变化的类就会比较少。
```



## 2、设计模式

### 一、创建型设计模式

```
创建型设计模式包括：单例模式、工厂模式、建造者模式、原型模式。
它主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。
```

#### 1、单例模式

```
单例模式用来创建全局唯一的对象。
一个类只允许创建一个对象(或者叫实例)，那这个类就是一个单例类，这种设计模式叫做单例模式。

单例有几种经典的实现方式,它们分别是：饿汉式、懒汉式、双重检测、静态内部类、枚举。
```

```
尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式(anti-pattern),并不推荐使用，主要的理由有以下几点：

单例对 OOP 特性的支持不友好
单例会隐藏类之间的依赖关系
单例对代码的扩展性不友好
单例对代码的可测试性不友好
单例不支持有参数的构造函数
```

```
那有什么替代单例的解决方案呢？如果要完全解决这些问题，我们可能要从根上寻找其他方式来实现全局唯一类。比如，通过工厂模式、IOC容器来保证全局唯一性。
```

```
有人把单例当做反模式，主张杜绝在项目中使用。
我个人觉得这有些极端。
模式本身没有对错，关键看你怎么用。
如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。
对于一些全局类，我们在其他地方 new 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。
```

#### 2、工厂模式

```
工厂模式包括简单工厂、工厂方法、抽象工厂这3种细分模式。
其中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。
```

```
工厂模式用来创建不同但是相关类型的对象(继承同一父类或接口的一组子类)，由给定的参数来决定哪种类型的对象。
实际上，如果创建对象的逻辑并不复杂，那我们直接通过 new 来创建对象就可以了，不需要使用工厂模式。
当创建逻辑比较复杂，是一个"大工程"的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。
```

```
当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。
当每个对象创建逻辑都比较复杂的时候，为了避免设计一个多于庞大的工厂类，我们推荐使用工厂方法模式，将创建逻辑拆分的更细，每个对象的创建逻辑独立到各自的工厂类中。
```

```
详细点说，工厂模式的作用有下面4个，这也是判断要不要使用工厂模式最本质的参考标准。

封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。

代码复用：创建代码抽离到独立的工厂类之后可以复用。

隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。

控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。
```

```
除此之外，我们还讲了工厂模式一个非常经典的应用场景：
依赖注入框架，比如 Spring IOC、Google Guice, 它用来集中创建、组装、管理对象，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。
DI框架已经成为了我们平时开发的必备框架。
```

#### 3、建造者模式

```
建造者模式用来创建复杂对象，可以通过设置不同的可选参数，"定制化"的创建不同的对象。
建造者的原理和实现比较简单，重点是掌握应用场景，避免过度使用。

如果一个类中有很多属性，为了避免构造函数的参数过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。
但是，如果存在下面一个情况中的任意一种，我们就要考虑使用建造者模式了。
```

```
1、
我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。
如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。
如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。
```

```
2、
如果类的属性之间有一定的依赖关系或者约束关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。
```

```
如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露set()方法。构造函数配合set()方法来设置属性值的方式就不适用了。
```

#### 4、原型模式

```
如果对象的创建成本比较大，而同一个类的不同对象之间差别不大(大部分字段都相同)，在这种情况下，我们可以利用对已有对象(原型)进行复制(或者拷贝)的方式，来创建新对象，已达到节省创建时间的目的。
这种基于原型来创建对象的方式就叫做原型模式。
```

```
原型模式有两种实现方法，深拷贝和浅拷贝。
浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归的复制引用对象，以及引用对象的引用对象...而深拷贝得到的是一份完完全全独立的对象。
所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。
```

```
如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。
除非操作非常耗时，比较推荐使用浅拷贝，否则，没有充分的理由，不要为了一点点的性能而使用浅拷贝。
```



### 二、结构型设计模式

```
结构性模式主要总结了一些类或对象组合在一起的经典结构，这些经典的接口可以解决特定应用场景的问题。
结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。
```



#### 1、代理模式

```
代理模式下载不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰者模式最大的不同。
一般情况下，我们让代理类和原始类实现同样的接口。
但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。
在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。
```

```
静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板模式的"重复"代码，增加了维护成本和开发成本。
对于静态代理存在的问题，我们可以通过动态代理来解决。
我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。
```

```
代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。
我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。
除此之外，代理模式还可以用在 RPC、缓存等应用场景中。
```



#### 2、桥接模式

```
桥接模式的代码实现非常简单，但是理解起来稍微有些难度，并且应用场景也比较局限，所以，相对来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以了，并不是我们学习的重点。
```

```
桥接模式有两种理解方式。
第一种理解方式是"将抽象和实现解耦，让它们能独立开发"。
这种理解方式比较特别，应用场景也不多。
另一种理解方式更加简单，等同于"组合优于继承"设计原则，这种理解方式更加通用，应用场景比较多。
不管是那种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。
```

```
对于第一种理解方式，弄懂定义中"抽象"和"实现"两个概念，是理解它的关键。
定义中的"抽象"，指的并非"抽象类"或"接口"，而是被抽象出来的一套"类库"，它只包含骨架代码，真正的业务逻辑需要委派给定义中的"实现"来完成。

而定义中的"实现"，也并非"接口的实现类"，而是一套独立的"类库"。
"抽象"和"实现"独立开发，通过对象之间的组合关系组装在一起。
```



#### 3、装饰者模式

```
装饰者模式主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。
这也是判断是否该用装饰器模式的一个重要的依据。
除此之外，装饰器模式还有一个特点，那就是对原始类嵌套使用多个装饰器。
为了满足这样的需求，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。
```



#### 4、适配器模式

```
代理模式、装饰器模式提供的都是跟原始类相同的接口，而适配器提供跟原始类不同的接口。
适配器模式是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。
适配器模式有两种实现方式：类适配器和对象适配器。
其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。
```

```
适配器模式是一种事后的补救策略，用来补救设计上的缺陷。
应用这种设计模式算是"无奈之举"。
如果在设计初期，我们就能规避接口不兼容的问题，那这种设计模式就无用武之地了。
在实际的开发中，什么情况下才会出现接口不兼容呢？
```

```
我总结了下面这5种场景：
封装有缺陷的接口设计
统一多个类的接口设计
替换依赖的外部系统
兼容老版本的接口
适配不同格式的数据
```

#### 5、门面模式

```
门面模式原理、实现都非常简单，应用场景比较明确。
它通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题。
```























