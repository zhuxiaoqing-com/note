第三章 数据链路层



```
数据链路层协议几乎总是把 CRC 放在尾部，而不是放在头部，为什么

答案：
	CRC是在发送期间进行计算的。
	一旦把最后一位数据送上外出线路，就立即把CRC编码附加在输出流的后面发出。
	如果CRC放在帧的头部，那么就要在发送之前把整个帧先检查一遍来计算CRC。
	这样每个字节都要处理两遍，第一遍是为了计算检验码，第二遍是为了发送。
	把CRC放在尾部就可以把处理时间减半。
```





```
数据链路层属于计算机网络的低层。数据链路层使用的信道主要有以下两种类型：

1、点对点信道。这种信道使用一对一的点对点通信方式。

2、广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。
广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。 
```

```
局域网虽然是个网络，但我们并不把局域网放在网络中讨论。
这是因为在网络层要讨论的问题是分组怎么样从一个网络通过路由器转发到另一个网络，
但在本章中我们研究的是在同一个局域网中，分组怎样从一个主机传送到另一个主机(不经过路由器)。
因此，这是属于数据链路层的范围。
```

```
本章的大致内容是：
	1、数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议(PPP 协议以及 CSMA/CD协议)的特点。
	2、数据链路层的三个基本问题：封装成帧、透明传输和差错检测。
	3、适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合。
```



## 1、使用点对点信道的数据链路层

### 1、数据链路和帧

```
我们在这里要明确一下，"链路"和"数据链路"并不是一回事。
```

```
所谓链路"link"就是从一个结点到相邻结点的一段物理线路(有线或无线)，而中间没有任何其他的交换结点。
在进行数据通信时，两个计算机之间的通信路径往往要经过许多段这样的链路。
可见链路只是一条路径的组成部分。
```

```
数据链路(data link)则是另一个概念。
这是因为当需要在一条线上传送数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输。
若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。
现在最常用的方法是使用 网络适配器(既有硬件，也包括软件)来实现这些协议。
一般的适配器都包括了数据链路层和物理层这两层的功能。
```

```
也有人采用另外的术语。
这就是把链路分为物理链路和逻辑链路。
物理链路就是上面所说的链路，而逻辑链路就是上面的数据链路，是物理链路加上必要的通信协议。
```

```
早期的数据通信协议曾叫作通信规程(procedure)。
因此在数据链路层，规程和协议是同义词。
```

```
下面再介绍点对点信道的数据链路层的协议数据单元 --- 帧。
```

```
数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。
在因特网中，网络层协议数据单元就是IP数据报(或简称为数据报、分组或包)。
```

```
为了把主要精力放在点对点信道的数据链路层协议上，可以采用如图 3-3(a)所示的三层模型。
```

![](images01-01/01-01.jpg)

```
点对点信道的数据链路层在进行通信时的主要步骤如下：
1、结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。
2、结点A把封装好的帧发送给结点B的数据链路层。
3、若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报上交给上面的网络层；否则丢弃这个帧。

数据链路层不必考虑物理层如何实现比特传输的细节。
我们甚至还可以更简单的设想好像是沿着两个数据链路层之间的水平方向把帧直接发送给对方，如图3-3(b)所示。
```

### 2、三个基本问题

```
数据链路层协议有许多种，但有三个基本问题则是共同的。
这三个基本问题是：封装成帧、透明传输和差错检测。
下面分别讨论这三个基本问题。
```

#### 1、封装成帧

```
封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。
接收端再收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。

图3-4表示用帧首部和帧尾部封装成帧的一般概念。
我们知道，分组交换的一个重要的概念就是：
所有因特网上传送的数据都是以分组(即IP数据报)为传送单位的。

网络层的ip数据报传送到数据链路层就成为帧的数据部分。
在帧的数据部分的前面和后面分别添加上首部和尾部，构成了一个完整的帧。
这样的帧就是数据链路层的数据传送单元。

一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。
首部和尾部的一个重要作用就是进行帧定界(即确定帧的界限)。
此外，首部和尾部还包括许多必要的控制信息。
在发送帧时，是从帧首部开始发送。
各种数据链路层协议都对帧首部和帧尾部的格式有明确的规定。
显然，为了提高帧的传输效率，应当使帧的数据部分长度尽可能的大于首部和尾部的长度。

但是，每一种链路层协议都规定了所能传送的帧的数据部分长度上限 --- 最大传送单元 MTU(Maximum Transfer Unit)。
图3-4给出了帧的首部和尾部的位置，以及帧的数据部分与MTU的关系。
```

![](images01-01/01-02.jpg)

```
当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的帧定界符。
我们知道，ASCII 码是7位编码，一共可组成128个不同的 ASCII 码，其中可打印的有95个，而不可打印的控制字符有33个。
```

![](images01-01/01-03.jpg)

![](images01-01/01-04.jpg)

```
当数据在传输中出现差错时，帧定界符的作用更加明显。
假定发送端在尚未发送完一个帧时突然出故障，中断了发送。
但随后很快有恢复正常，于是重新从头开始发送刚才未发送完的帧。
由于使用了帧定界符，在接收端就知道前面收到的数据是个不完整的帧(只有首部开始符 SOH 没有传输结束符EOT)，必须丢弃。
而后面收到的数据有明确的帧定界符(SOH和EOT)，因此这是一个完整的帧，应当收下。
```

#### 2、透明传输

```
由于帧的开始和结束的标记是使用专门指明的控制字符，因此，所传输的数据中的任何8比特的组合一定不允许和用作帧定界的控制字符的比特编码一样，否则会出现帧定界的错误。
```

![](images01-01/01-05.jpg)

```
像图 3-6 所示的帧的传输显然就不是"透明传输"，因为当遇到数据中碰巧出现字符"EOT"时就传不过去了。
数据中的"EOT"被接收端当作是无效帧而丢弃。
但实际上在数据中出现的字符"EOT"并非控制字符而仅仅是二进制数据 00000100。
```

```
前面提到的"透明"是一个很重要的术语。
它表示:某一个实际存在的事物看起来缺是好像不存在一样。
在数据链路层透明传送数据，表示无论什么样的比特组合的数据都能够通过这个数据链路层。
因此，对所传送的数据来说，这些数据就"看不见"数据链路层有什么妨碍数据传输的东西。
或者说，数据链路层对这些数据来说是透明的。
```

```
为了解决透明传输问题，就必须设法使数据中可能出现的控制字符 "SOH" 和 "EOT" 在接收端不被解释为控制字符。

具体的方法是：发送端的数据链路层在数据中出现控制字符"SOH"或"EOT"的前面插入一个转义字符"ESC"(其十六进制编码时 1B，二进制是 00011011)。
而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。

这种方法称为字节填充"byte stuffing" 或字符填充(character stuffing)。
如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符前面插入一个转义字符。
因此，当接收端收到连续的两个转义字符时，就删除其中前面的一个。

图3-7表示用字节填充法 解决透明传输的问题。
```

![](images01-01/01-06.jpg)



#### 3、差错检测

```
现实的通信链路都不会是理想的。
这就是说，比特在传输过程中可能会产生差错：
1可能会变成0，而0也可能变成1.这就叫做比特差错。
比特差错时传输差错中的一种。
本小节所说的 "差错"，如无特殊说明，就是指"比特差错"。
在一段时间内，传输错误的比特占所传输比特总数的比率称为 误码率BER(bit error rate).

例如，误码率为 10^-10 时，表示平均每传送 10^10 个比特就会出现一个比特的差错。
误码率与信噪比有很大的关系。
如果设法提高信噪比，就可以使误码率减小。

实际的通信链路并非是理想的，它不可能使误码率下降到零。
因此，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。
目前在数据链路层广泛使用了 循环冗余检验 CRC(cyclic Redundancy Check)的检错技术。
```

```
下面我们通过一个简单的例子来说明循环冗余检验的原理.

在发送端,先把数据划分为组,假定每组 k 个比特。
现假定待发送数据 M = 101001(k = 6).
CRC 运算就是在数据 M 的后面添加供差错检验用的 n 位冗余码，然后构成一个帧发送出去，一共发送(k+n)位。
在所要发送的数据后面增加 n 位冗余码，虽然增大了数据传输的开销，
但却可以进行差错检验。
当传输可能出现差错时，付出这种代价往往是很值得的。
```



```
注：用模2运算进行加法时不进位，
例如 1111+1010=0101。
减法和加法一样，按加法规则计算。
```

```
这 n 位冗余码可用以下方法得出。
用二进制的模2运算进行2^n乘 M 的运算，这相当于在 M 后面添加 n 个 0。
得到的 (k+n)位的数除以收发事先商定的长度为(n+1)位的除数 P,得出商是 Q 而余数是 R(n位，比P少一位)。
关于除数P下面还要介绍。
在图3-8所示的例子中，M = 101001(即k=6)。
假定除数P=1101(即n=3)。
经模2除法运算后的结果是 ：商Q = 110101(这个商并没有什么用处)，而余数R = 001。
这个余数R就作为冗余码拼接在数据M的后面发送出去。
这种为了进行检错而添加的冗余码常称为帧检验序列FCS(Frame Check Sequence).
因此加上FCS后发送的帧时 101001001 即 (2^n)M+FCS，共有(k+n)位。
```

![](images01-01/01-07.jpg)

```
顺便说一下，循环冗余检验CRC 和 帧检验序列FCS并不是同一个概念。
CEC是一种检错方法，
而FCS是添加在数据后面的冗余码，
在检验方法上可以选用CRC，但也可不选用CRC。
```

