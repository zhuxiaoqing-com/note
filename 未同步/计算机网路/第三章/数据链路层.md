第三章 数据链路层



```
数据链路层协议几乎总是把 CRC 放在尾部，而不是放在头部，为什么

答案：
	CRC是在发送期间进行计算的。
	一旦把最后一位数据送上外出线路，就立即把CRC编码附加在输出流的后面发出。
	如果CRC放在帧的头部，那么就要在发送之前把整个帧先检查一遍来计算CRC。
	这样每个字节都要处理两遍，第一遍是为了计算检验码，第二遍是为了发送。
	把CRC放在尾部就可以把处理时间减半。
```





```
数据链路层属于计算机网络的低层。数据链路层使用的信道主要有以下两种类型：

1、点对点信道。这种信道使用一对一的点对点通信方式。

2、广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。
广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。 
```

```
局域网虽然是个网络，但我们并不把局域网放在网络中讨论。
这是因为在网络层要讨论的问题是分组怎么样从一个网络通过路由器转发到另一个网络，
但在本章中我们研究的是在同一个局域网中，分组怎样从一个主机传送到另一个主机(不经过路由器)。
因此，这是属于数据链路层的范围。
```

```
本章的大致内容是：
	1、数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议(PPP 协议以及 CSMA/CD协议)的特点。
	2、数据链路层的三个基本问题：封装成帧、透明传输和差错检测。
	3、适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合。
```



## 1、使用点对点信道的数据链路层

### 1、数据链路和帧

```
我们在这里要明确一下，"链路"和"数据链路"并不是一回事。
```

```
所谓链路"link"就是从一个结点到相邻结点的一段物理线路(有线或无线)，而中间没有任何其他的交换结点。
在进行数据通信时，两个计算机之间的通信路径往往要经过许多段这样的链路。
可见链路只是一条路径的组成部分。
```

```
数据链路(data link)则是另一个概念。
这是因为当需要在一条线上传送数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输。
若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。
现在最常用的方法是使用 网络适配器(既有硬件，也包括软件)来实现这些协议。
一般的适配器都包括了数据链路层和物理层这两层的功能。
```

```
也有人采用另外的术语。
这就是把链路分为物理链路和逻辑链路。
物理链路就是上面所说的链路，而逻辑链路就是上面的数据链路，是物理链路加上必要的通信协议。
```

```
早期的数据通信协议曾叫作通信规程(procedure)。
因此在数据链路层，规程和协议是同义词。
```

```
下面再介绍点对点信道的数据链路层的协议数据单元 --- 帧。
```

```
数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。
在因特网中，网络层协议数据单元就是IP数据报(或简称为数据报、分组或包)。
```

```
为了把主要精力放在点对点信道的数据链路层协议上，可以采用如图 3-3(a)所示的三层模型。
```

![](images01-01/01-01.jpg)

```
点对点信道的数据链路层在进行通信时的主要步骤如下：
1、结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。
2、结点A把封装好的帧发送给结点B的数据链路层。
3、若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报上交给上面的网络层；否则丢弃这个帧。

数据链路层不必考虑物理层如何实现比特传输的细节。
我们甚至还可以更简单的设想好像是沿着两个数据链路层之间的水平方向把帧直接发送给对方，如图3-3(b)所示。
```

### 2、三个基本问题

```
数据链路层协议有许多种，但有三个基本问题则是共同的。
这三个基本问题是：封装成帧、透明传输和差错检测。
下面分别讨论这三个基本问题。
```

#### 1、封装成帧

```
封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。
接收端再收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。

图3-4表示用帧首部和帧尾部封装成帧的一般概念。
我们知道，分组交换的一个重要的概念就是：
所有因特网上传送的数据都是以分组(即IP数据报)为传送单位的。

网络层的ip数据报传送到数据链路层就成为帧的数据部分。
在帧的数据部分的前面和后面分别添加上首部和尾部，构成了一个完整的帧。
这样的帧就是数据链路层的数据传送单元。

一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。
首部和尾部的一个重要作用就是进行帧定界(即确定帧的界限)。
此外，首部和尾部还包括许多必要的控制信息。
在发送帧时，是从帧首部开始发送。
各种数据链路层协议都对帧首部和帧尾部的格式有明确的规定。
显然，为了提高帧的传输效率，应当使帧的数据部分长度尽可能的大于首部和尾部的长度。

但是，每一种链路层协议都规定了所能传送的帧的数据部分长度上限 --- 最大传送单元 MTU(Maximum Transfer Unit)。
图3-4给出了帧的首部和尾部的位置，以及帧的数据部分与MTU的关系。
```

![](images01-01/01-02.jpg)

```
当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的帧定界符。
我们知道，ASCII 码是7位编码，一共可组成128个不同的 ASCII 码，其中可打印的有95个，而不可打印的控制字符有33个。
```

![](images01-01/01-03.jpg)

![](images01-01/01-04.jpg)

```
当数据在传输中出现差错时，帧定界符的作用更加明显。
假定发送端在尚未发送完一个帧时突然出故障，中断了发送。
但随后很快有恢复正常，于是重新从头开始发送刚才未发送完的帧。
由于使用了帧定界符，在接收端就知道前面收到的数据是个不完整的帧(只有首部开始符 SOH 没有传输结束符EOT)，必须丢弃。
而后面收到的数据有明确的帧定界符(SOH和EOT)，因此这是一个完整的帧，应当收下。
```

#### 2、透明传输

```
由于帧的开始和结束的标记是使用专门指明的控制字符，因此，所传输的数据中的任何8比特的组合一定不允许和用作帧定界的控制字符的比特编码一样，否则会出现帧定界的错误。
```

![](images01-01/01-05.jpg)

```
像图 3-6 所示的帧的传输显然就不是"透明传输"，因为当遇到数据中碰巧出现字符"EOT"时就传不过去了。
数据中的"EOT"被接收端当作是无效帧而丢弃。
但实际上在数据中出现的字符"EOT"并非控制字符而仅仅是二进制数据 00000100。
```

```
前面提到的"透明"是一个很重要的术语。
它表示:某一个实际存在的事物看起来缺是好像不存在一样。
在数据链路层透明传送数据，表示无论什么样的比特组合的数据都能够通过这个数据链路层。
因此，对所传送的数据来说，这些数据就"看不见"数据链路层有什么妨碍数据传输的东西。
或者说，数据链路层对这些数据来说是透明的。
```

```
为了解决透明传输问题，就必须设法使数据中可能出现的控制字符 "SOH" 和 "EOT" 在接收端不被解释为控制字符。

具体的方法是：发送端的数据链路层在数据中出现控制字符"SOH"或"EOT"的前面插入一个转义字符"ESC"(其十六进制编码时 1B，二进制是 00011011)。
而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。

这种方法称为字节填充"byte stuffing" 或字符填充(character stuffing)。
如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符前面插入一个转义字符。
因此，当接收端收到连续的两个转义字符时，就删除其中前面的一个。

图3-7表示用字节填充法 解决透明传输的问题。
```

![](images01-01/01-06.jpg)



#### 3、差错检测

```
现实的通信链路都不会是理想的。
这就是说，比特在传输过程中可能会产生差错：
1可能会变成0，而0也可能变成1.这就叫做比特差错。
比特差错时传输差错中的一种。
本小节所说的 "差错"，如无特殊说明，就是指"比特差错"。
在一段时间内，传输错误的比特占所传输比特总数的比率称为 误码率BER(bit error rate).

例如，误码率为 10^-10 时，表示平均每传送 10^10 个比特就会出现一个比特的差错。
误码率与信噪比有很大的关系。
如果设法提高信噪比，就可以使误码率减小。

实际的通信链路并非是理想的，它不可能使误码率下降到零。
因此，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。
目前在数据链路层广泛使用了 循环冗余检验 CRC(cyclic Redundancy Check)的检错技术。
```

```
下面我们通过一个简单的例子来说明循环冗余检验的原理.

在发送端,先把数据划分为组,假定每组 k 个比特。
现假定待发送数据 M = 101001(k = 6).
CRC 运算就是在数据 M 的后面添加供差错检验用的 n 位冗余码，然后构成一个帧发送出去，一共发送(k+n)位。
在所要发送的数据后面增加 n 位冗余码，虽然增大了数据传输的开销，
但却可以进行差错检验。
当传输可能出现差错时，付出这种代价往往是很值得的。
```



```
注：用模2运算进行加法时不进位，
例如 1111+1010=0101。
减法和加法一样，按加法规则计算。
```

```
这 n 位冗余码可用以下方法得出。
用二进制的模2运算进行2^n乘 M 的运算，这相当于在 M 后面添加 n 个 0。
得到的 (k+n)位的数除以收发事先商定的长度为(n+1)位的除数 P,得出商是 Q 而余数是 R(n位，比P少一位)。
关于除数P下面还要介绍。
在图3-8所示的例子中，M = 101001(即k=6)。
假定除数P=1101(即n=3)。
经模2除法运算后的结果是 ：商Q = 110101(这个商并没有什么用处)，而余数R = 001。
这个余数R就作为冗余码拼接在数据M的后面发送出去。
这种为了进行检错而添加的冗余码常称为帧检验序列FCS(Frame Check Sequence).
因此加上FCS后发送的帧时 101001001 即 (2^n)M+FCS，共有(k+n)位。
```

![](images01-01/01-07.jpg)

```
顺便说一下，循环冗余检验CRC 和 帧检验序列FCS并不是同一个概念。
CEC是一种检错方法，
而FCS是添加在数据后面的冗余码，
在检验方法上可以选用CRC，但也可不选用CRC。
```

[CRC在发送中校验](https://www.cnblogs.com/94cool/p/3559585.html)

```
在接收端把接收到的数据以帧为单位进行CRC校验：把收到的每一个帧都除以同样的除数P(模2运算)，然后检查得到的余数R。
```

```
如果在传输过程中无差错，那么经过CRC校验后得出的余数R肯定是0。
```

```
但如果出现误码，那么余数R仍等于零的概率是非常非常小的(详情请看书)。
```

```
总之，在接收端对收到的每一帧经过CRC校验后，有以下两种情况
1、若得出的余数R=0，则判定这个帧没有差错，就接受accept.
2、若余数R!=0,则判定这个帧有差错(但无法确定究竟是哪一位或哪几位出现了差错)，就丢弃。
```

```
一种较方便的方法是用多项式来表示循环冗余检验过程。
在上面的例子中，用多项式 P(X)=X^3+X^2+1 表示上面的除数 P =1101 (最高位对应于 X^3, 最低位对应于 X^0)。 
多项式P(X)称为生成多项式。
现在广泛使用的生成多项式P(X)有以下几种：

X^0 就是 1;
```

![](images01-01/01-08.jpg)

```
在数据链路层，发送端帧检验序列 FCS 的生成和接收端的 CRC 检验都是用硬件完成的，处理很迅速，因此并不会延误数据的传输。
```



```
以上的讨论不难看出，如果我们在传送数据时不以帧为单位来传送，那么就无法加入冗余码以进行差错检验。
因此，如果要在数据链路层进行差错检验，就必须把数据划分为帧，每一帧都加上冗余码，一帧接一帧的传送，然后在接收方逐帧进行差错检验。
```

```
最后再强调一下，在数据链路层若仅仅使用循环冗余检验CRC差错检验技术，则只能做到对帧的无差错接受，即:"凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错"。
接收端丢弃的帧虽然曾收到了，但最终还是因为有差错被丢弃，即没有被接受。
以上所述的可以近似地表述为(通常都是这样认为)："凡是接收端数据链路层接受的帧均无差错"。
```

```
请注意，我们现在并没有要求数据链路层想网络层提供"可靠传输"的服务。
所谓"可靠传输"就是：数据链路层的发送端发送什么，在接收端就收到什么。
传输差错可分为两大类：
	一类就是前面所说的最基本的比特差错，
	而另一类传输差错则更复杂些，这就是收到的帧并没有出现比特差错，
	但却出现了帧丢失、帧重复或帧失序。
```

![](images01-01/01-09.jpg)

```
以上三种情况都属于"出现传输差错"，但都不是这些帧里有"比特差错"。
帧丢失很容易理解。
但出现帧重复和帧失序的情况则较为复杂，对这些问题我们现在不展开讨论。
我们在后面章节会讨论。
```

```
总之，我们应当明确，"无比特差错"与"无传输差错"并不是同样的概念。
在数据链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输。
```

```
我们知道，过去OSI的观点是：必须让数据链路层向上提供可靠传输。
因此在CRC检错的基础上，增加了帧编码、确认和重传机制。
收到正确的帧就要向发送端发送确认。
发送端在一定的期限内若没有收到对方的确认，就认为出现了差错，因而就进行重传，知道收到对方的确认为止。
这种方法在历史上曾经起到了很好的作用。
但现在的通信线路的质量已经大大提高了，由通信链路质量不好引起差错的概率已经大大降低。
因此，现在因特网就采取了区别对待的方法：
```

```
对于通信质量良好的有限传输链路，数据链路层不使用确认和重传机制，即不要求数据链路层向上提供可靠传输的服务。
如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由上层协议(例如，运输层的TCP协议)来完成。
```

```
对于通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务。(见第九章 无线网络)
```

```
实践证明，这样做可以提高通信效率。
```

## 2、网络上的PPP协议讲解

[网络上的PPP协议讲解](https://www.cnblogs.com/5iedu/p/6940007.html)

### 1、点到点通信

```
1、点到点信道是指一条链路上就一个发送端和接收端的信道，通常用在广域网链路。
如两个路由器通过串口相连或家庭用户使用调制调节器通过电话线拨号连接ISP。
```

![](images01-01/01-10.jpg)



```
2、早期通信线路质量差，在数据链路层使用可靠传输协议(HDLC,高级数据链路控制协议)。
现在最广泛使用的是较为简单的PPP点到点协议。
```

### 2、PPP协议的特点

```
1、简单：PPP协议不负责可靠传输、纠错和流量控制，也不需要给帧编号，接收端收到帧后就进行CRC检验。
如果正确就收下，反之直接丢弃，其他什么也不做。

2、封装成帧：每种数据链路层协议都是特定的帧定界符，用于接收端从收到的比特流中准确的找到帧开始和结束的位置。

3、透明传输：保证数据传输的透明性。比如数据中碰巧出现了和帧定界符一样的比特组合时，要采取有效措施来解决。

4、通过检测技术将传输中出现差错的帧丢弃，以防止出错的帧被继续转发而白白浪费了网络资源。

5、支持多种网络层协议：同一条物理链路上同时支持多种网络协议(如 IP和 IPV6)。这意味着IP数据报和IPV6数据都可以封装在PPP帧中进行传输。

6、多种类型链路：能够在多种类型的链路上运行(如串行或并行、同步或异步、低速或高速、电或光等)。

7、检测连接状态：具有一种机制能够及时自动检测出链路是否处于正常工作状态。
当出现故障的链路隔一段时间后又重新恢复正常是，就特别需要这种检测功能

8、最大传送单元：当高层协议发送的分组过长并超过MTU数据值，PPP就要丢弃这样的帧，并返回差错。(注意：MTU指的是帧的数据部分的最大长度，而不是帧的总长度)。

9、网络层地址协商：PPP协议提供一种机制使通信的两个网络层实体能够通过协商知道或配置彼此的网络层地址(ADSL拨号上网，ISP给的是一个公网地址)，这就是PPP协议的功能。

10、数据压缩协商：提供一种协商使用数据压缩算法，但PPP协议并不要求将数据压缩算法进行标准化。
```

### 3、PPP协议的组成

![](images01-01/01-11.jpg)

```
1、高级数据链路层控制协议：将IP数据报封装到串行链路的方法。既支持异步链路也支持同步链路。

2、链路控制协议：用来建立、配置和测试数据链路的连接，通信的双方可协商一些选项。

3、网络控制协议：支持不同的网络协议，如IP、IPv6、DECent 以及 AppleTalk 等。
```

### 4、串行通信的同步传输和异步传输

#### 1、同步传输

![](images01-01/01-12.jpg)

```
1、同步传输以数据帧为单位传输数据(注意每个数据帧的大小是不固定的！)。

2、在短距离的高速传输中，时钟信号可由专门的时钟线路传输。双方按相同的时钟信号进行收发。

3、计算机网络采取的同步方式，常将时钟信号(前同步码)植入数据信号帧中，以时间接收端与发送端的时钟同步。
也有用专门的一个 带宽段专门进行时间 频率同步的。
```

#### 2、异步传输

![](images01-01/01-13.jpg)

```
1、异步传输以字符为单位传输数据(注意：传输单位是固定的，如8比特为一个单位)。
2、异步传输通过字符开始的开始码和停止码抓住再同步的机会，而同步传输则是从前同步码中抽取同步信息。
3、异步传输每个字符中要多传递2比特信息，总传输负载量增加不小。
其传输效率比同步传输效率低。
```

#### 3、同步传输和异步传输的区别

```
1、异步传输是面向字符的传输，传输单位为字符。
而同步传输是面向比特的传输，传输单位是帧。
2、异步传输通过字符的开始码和停止码抓住再同步的机会，而同步传输则是从前同步码中抽取同步信息。
3、异步传输每个字符中要多传递2比特信息，总传输负载量增加不小。
其传输效率比同步传输效率低。
异步传输对于那些数据传输量的高速设备来说，增加了不少传输量。
因此，适合用于数据传输量较小的低俗设备。

同步传输的同步时钟有前同步码 网同步等方式

异步传输的同步方式是(群同步)根据起始位和停止位 然后根据事先规定的传输速率和协议格式来矫正时钟，因为每一个字符都会矫正一次时钟，所以时钟的准确性不需要像同步传输一样严格。
但是由于每一个字符都带了起始位和停止位 数据量就比同步传输要大多了。
```



### 5、PPP协议帧的格式

![](images01-01/01-14.jpg)

```
1、帧开始和结束定界符均为 0x7E
2、A字段为地址字段(值为0xFF),该字段没有源地址和目标地址，形同虚设。
C字段为控制字段(值为0x03，具体的定义至今没给出)。
3、FCS为2个字节的帧校验序列
4、信息部分的长度不超过15000字节。PPP是面向字节的，所有PPP帧的长度都是整数字节的倍数。
```

```
PPP首部的第四个字段是2字节的协议字段。
当协议字段为 0x0021时，PPP帧的信息字段就是IP数据报
当协议字段为 0xC021时，PPP帧的信息字段就是LCP数据报
当协议字段为 0x8021时，PPP帧的信息字段就是网络层的控制数据
```



#### 1、异步传输使用字节填充

![](images01-01/01-15.jpg)

```
1、在异步传输的链路上，数据传输是以自己为单位，PPP帧的转义字符定为0x7D,并使用字节填充。
2、把信息字段(即开始和结束定界符外)中出现的每一个0X7E字节转变为2字节的(0x7D,0x5E)。
3、若信息字段出现一个0x7D的字节(即出现了和转入字符一样的比特组合)，则把0x7D转变为2字节序列(0x7D,0x5D)
```

#### 2、同步传输使用零比特填充

![](images01-01/01-16.jpg)

```
1、在同步传输的链路上，数据传输以帧为单位，PPP协议采用零比特填充的方法来实现透明传输。(注意PPP协议帧定界符为0x7E,二进制位 0111 1110)
2、发送端先扫描整个信息字段(通常由硬件实现)，只要发现有连接的5个1，则立即填入一个0.
从而保证在信息字段中不会出现帧定界符(6个连续的1)
3、接收端收到数据后，从确定一个帧的开始，接着扫描比特流，如果发现连续的5个1，就把其后的0删除，还原成原来的信息比特流。
```



### 3、PPP协议的工作状态

```
上一节我们通过 ppp帧的格式讨论了 PPP 帧时怎样组成的。
但PPP链路一开始是怎样被初始化的？
当用户拨号接入ISP后，就建立了一条从用户PC到ISP的物理连接。
这时，用户PC向ISP发送一系列的链路控制协议LCP分组(封装成多个PPP帧)，以便建立LCP连接。
这些分组及其相应选择了将要使用的一些 PPP 参数。
接着还要进行网络层配置，网络控制协议NCP给新接入的用户PC分配了一格临时的IP地址。
这样，用户PC就称为因特网上的一个有IP地址的主机了。
```

```
当用户通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。
接着LCP释放数据链路层连接。
最后释放的是物理层的连接。
```

```
上述过程可用图3-12的状态来描述。
```

![](images01-01/01-17.jpg)

```
PPP链路的起始和终止状态永远是图3-12中的"链路静止"(link Dead)状态，这时在用户PC和ISP的路由器之间并不存在物理层的连接。

当用户PC通过调制器呼叫路由器时(通常是在屏幕上用鼠标点击一个连接按钮)，路由器就能够检测到调制解调器发出的载波信号。
在双方建立了物理层连接后，PPP就进入了"链路建立"(link Establish)状态，其目的是建立链路层的LCP连接。
```

```
这时LCP开始协商一些配置选项，即发送LCP的配置请求帧(Configure-Request)。
这是个PPP帧，其协议字段置为LCP对应的代码，而信息字段包含特定的配置请求。
链路的另一端可以发送以下几种响应中的一种：

1、配置确认帧(Configure-Ack):所有选项都接受
2、配置否认帧(Configure-Nak):所有选项都理解但不能接受
3、配置拒绝帧(Configgure-Reject):选项有的无法识别或不能接受，需要协商。
```

```
LCP配置选项包括链路上的最长帧长、所使用的鉴别协议(authentication protocol) 的规约(如果有的话)，以及不使用 PPP 帧中的地址和控制字段(因为这两个字段的值是固定的，没有任何信息量，可以在PPP帧的首部中省略这两个字节)。
```

```
协商结束后双方就建立了LCP链路，接着就进入"鉴别"(Authenticate)状态。
在这一状态，值允许传送LCP协议的分组、鉴别协议的分组以及监测链路质量的分组。
若使用口令鉴别协议PAP(password Authentication protocl)，则需要发起通信额一方发送身份标识符和口令。系统可允许用户重试若干次。
如果需要有更好的安全性，则可以使用更加复杂的口令握手鉴别协议CHAP(Challenge-Handshake Authentication Protocol)。
若鉴别身份失败，则转到"链路终止"(Link Terminate)状态。

若鉴别成功，则进入"网络层协议"(Network-Laer Protocol)状态。
```

```
在"网络层协议"状态，PPP链路的两端的网络控制协议NCP根据网络层的不同协议互相交换网络层特定的网络控制分组。
这个步骤是很重要的，因为现在的路由器都能够同时支持多种的网络层协议。
总之，PPP协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个PPP协议进行通信。
```

```
如果在PPP链路上运行的是IP协议，则对PPP链路的每一端配置IP协议模块(如分配IP地址)时就要使用NCP中支持IP的协议 --- IP 控制协议IPCP(IP Control Protocol)。
IPCP分组也封装成PPP帧(其中的协议字段为0x8021)在PPP链路上传送。
在低速链路上运行时，双方还可以协商使用压缩的TCP和IP首部，以减少在链路上发送的比特数。
```

```
当网络层配置完毕后，链路就进入可进行数据通信的"链路打开"(link open)状态。
链路的两个PPP端点可以彼此向对方发送分组。
两个PPP端点还可以发送回送请求LCP分组(Echo-Request)和回送回答(Echo-Reply)，以检查链路的状态。
```

```
数据传输结束后，可以由链路的一端发出终止请求LCP分组(Terminate-Request)请求终止连接，在收到对方发来的终止确认LCP分组(Terminate-Ack)后，转到"链路终止"状态。
当调制解调器的载波停止后，则回到"链路静止"状态
```

```
图3-12的右方的灰色方框给出了对PPP协议的几个状态的说明。
从设备之间的无链路开始，到建立物理链路，再建立链路控制协议LCP链路。
经过鉴别后再建立网络控制协议NCP，然后才能交换数据。
由此可见，PPP协议已经不是纯粹的数据链路层的洗衣，它还包含了物理层和网络层的内容。
```























