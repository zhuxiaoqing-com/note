## 3、划分子网和构造超网

### 1、划分子网

#### 1、从两级IP地址到三级IP地址

```
在今天看来，在ARPANET 的早期，IP地址的设计确实不够合理。

第一，IP地址空间的利用率有时很低。

每一个A类地址网络可连接的主机数超过1000万台。
而每一个B类地址网络可连接的主机数也超过6万台。
然而有些网络对连接在网络上的计算机数目有限制，
根本达不到这样大的数值。
例如10BASE-T以太网规定其最大结点数只有1024个。
这样的以太网若使用一个B类地址就浪费6万多个IP地址，
地址空间利用率还不到2%，而其他单位的主机无法使用这些被浪费的地址。

有的单位申请到了一个B类地址网络，但所连接的主机数并不多，可是又不愿意申请一个足够使用的C类地址，理由是考虑到今后可能的发展.

IP地址的浪费，还会使IP地址空间的资源过早的被用完。
```

```
第二，给每一个物理网络分配一个网络号会使路由表变得太大因而时网络性能变坏。

每一个路由器都应当能够从路由表查出怎样到达网络的下一跳路由器。
因此，互联网中的网络数越多，路由器的路由表的项目数也就越多。

这样，即使我们拥有足够多的IP地址资源可以给每一个物理网络分配一个网络号，也会导致路由器中的路由表中的项目数过多。

这不仅增加了路由器的成本(需要更多的存储空间)，而且使查找路由时耗费更多的时间，同时也使路由器之间定期交换的路由信息急剧增加，因而使路由器和整个因特网的性能都下降了。
```

```
第三，两级IP地址不够灵活。

有些情况紧急，一个单位需要在新的地点马上开通一个新的网络。
但是在申请一个新的IP之前，新增加的网络是不可能连接到因特网上工作的。
我们希望有一种方法，使一个单位能随时灵活的增加本单位的网络，而不必事先到因特网管理机构去申请新的网络号。
原来的两级IP无法做到这一点。
```

```
为了解决上述问题，从1985年起在IP地址中又增加了一个"子网号字段"，使两级IP地址变成为三级IP地址，它能够较好的解决上述问题，并且使用起来也很灵活。
这种做法叫做 划分子网(subnetting)，或子网寻址 或 子网路由选择。

划分子网已成为因特网的正式标准协议。
```



划分子网的基本思路如下：

```
1、一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网(subnet)。
划分子网纯属一个单位内部的事情。
本单位以外的网络看不见这个网络是由多少个子网组成，因为这个单位对外仍然表现为一个网络。
```

```
2、划分子网的方法是从网络的主机号借用若干位 作为子网号 subnet-id,当然主机号也就相应减少了同样的位数。

于是两级IP地址在本单位内部就变为三级IP地址：
网络号、子网号和主机号。
也可以用以下记法来表示：

```

![](images02-01/01-01.jpg)

```
3、凡是从其他网络发送给本单位某个主机的IP数据报，仍然是根据IP数据报的目的网络号找到连接在本单位网络上的路由器。
但此路由器在收到IP数据报后，再按目的网络号和子网号找到目的子网，把IP数据报交付目的主机。
```

![](images02-01/01-02.jpg)

![](images02-01/01-03.jpg)

![](images02-01/01-04.jpg)

```
总之，当没有划分子网时，IP地址是两级结构。
划分子网后IP地址就变成了三级结构。
划分子网只是把IP地址的主机号这部分进行再划分，而不改变IP地址原来的网络号。
```

#### 2、子网掩码

```
现在剩下的问题就是：
假定有一个数据报(其目的地址是145.12.3.10)已经到达了路由器R1。
那么这个路由器如何把它转发到子网145.13.3.0呢？
```

```
我们知道，从IP数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子网的划分。

这是因为32位的IP地址本身以及数据报的首部都没有包含任何有关子网划分的信息。
因此必须另外想办法，这就是使用子网掩码(subnet mask)(见图4-20)。
```

![](images02-01/01-05.jpg)



```
图4-20(a)是IP地址为 145.13.3.10 的主机本来的两级IP地址结构。
图4-20(b)是这个两级IP地址的子网掩码。
图4-20(c)是同一地址的三级IP地址结构，也就是说，现在从原来16位的主机号中拿出8位作为子网号，而主机号由16位减少到8位。

请注意，现在子网号为3的网络的网络地址是145.13.3.0 (既不是原来两级IP地址的网络地址 145.13.0.0，也不是简单的子网号3)。
为了使路由器R1能够很方便的从数据报中的目的IP地址中提取出所要找的子网的网路地址，路由器R1就要使用三级IP地址的子网掩码。

图4-20(d)是三级IP地址的子网掩码，它也是32位，由一串1和跟随一串0组成。
子网掩码中的1对应于IP地址中原来二级地址中的16位网络号加上新增的8位子网号，而子网掩码中的0对应于现在的8位主机号。

虽然RFC文档中没有规定子网掩码中的一串1必须是连续的，但却极力推荐在子网掩码中选用连续的1，以免出现可能发生的差错。
```

```
图4-20(e)表示R1把三级IP地址的子网掩码和收到的数据报的目的IP地址145.13.3.10 逐位相"与"(AND)(计算机进行这种逻辑AND运算是很容易的)，
得出了所要找的子网的网络地址145.13.3.0。
```

```
使用子网掩码的好处就是:
不管网络有没有划分子网，只要把子网掩码和IP地址进行逐位的"与"运算(AND),就立即得出网络地址来。
这样在路由器处理到来的分组时就可采用同样的算法。
```

```
归纳一下上述的要点。
从网络145.13.0.0外面看，这就是一个普通的B类网络，其子网掩码为16个连1后面跟上16个连0。

但进入到这个网络后(即到了路由器R1)，就看到了还有许多网络(即划分了子网后的许多网络)，其网络地址是 145.13.x.0(这里的x可以表示为不同的数值)，而这些网络的子网掩码都是24个连1后面跟上8个连0。
总之，在这个B类网络的外面和里面，看到的网络是不一样的。
```

```
这里还要弄清一个问题，这就是：
在不划分子网时，既然没有子网，为什么还要使用子网掩码？
这就是为了更便于查找路由表。
现在因特网的标准规定：所有的网路都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。

如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码。

默认子网掩码中的1的位置和IP地址汇总的网络号字段net-id正好相对应。
因此，若用默认子网掩码和某个不划分子网的IP地址逐位相"与"(AND),就应当能够得出该IP地址的网络地址来。
```

```
这样做可以不用查找该地址的类别位就能知道这是哪一类的IP地址。
显然，
A类地址的默认子网掩码是255.0.0.0，或0xFF000000；
B类地址的默认子网掩码是255.255.0.0，或0xFFFF0000；
C类地址的默认子网掩码是255.255.255.0，或0xFFFFFF00；
```

```
图4-21是这三类IP地址的网络地址和相应的默认子网掩码。
```

![](images02-01/01-06.jpg)

```
子网掩码是一个网络或一个子网的重要属性。
在RFC950成为因特网的正式标准后，路由器在和相邻路由器交换路由信息时，必须把自己所在网络(或子网)的子网掩码告诉相邻路由器。
在路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。
若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。
```

![](images02-01/01-07.jpg)

```
在表中4-6中，子网数是根据子网号subnet-id计算出来的。
若subnet-id有n位，则共有2^n种可能的排列。
除去全0和全1这两种情况，就得出表中的子网数。

表中"子网号的位数"中没有0,1,15,和16这四种情况，因为这没有意义。
0的话就是B类地址
1的话 只有0,1两位;又因为0就是B类地址,所以是有1有用;只有一个子网也没有意义。

15的话 主机号只有0,1 而全0和全1;代表的是本网络和所有主机;没有意义

16的话 就只有网络号 没有子网号了;
```

```
请读者注意，虽然根据已成为因特网标准协议的RFC950文档，子网号不能为全1或全0，但随着无分类域间路由选择CIDR的广泛使用，现在全1和全0的子网号也可以使用了，但一定要谨慎使用，要弄清你的路由器所用的路由选择软件是否支持全0或全1的子网号这种较新的用法。
```

```
我们可以看出，若使用较少位数的子网号，则每一个子网上可连接的主机数就较多。
凡是若使用较多位数的子网号，则子网的数目较多但每个子网上可连接的主机数就较少。

因此我们可根据具体情况(一共需要划分多少个子网，每个子网中最多有多少个主机)来选择合适的子网掩码。
```

```
通过简单的计算，读者不难得出这样的结论：划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。
例如，本来一个B类网络最多可连接65534台主机，但表4-6中任意一行的最后两项的乘积一定小于65534.

对A类和C类地址的子网划分也可得出类似的表格，读者可自行算出。
```

**例子**

![](images02-01/01-08.jpg)

```
例4-2 
	已知IP地址是141.14.72.24, 子网掩码是255.255.192.0。
	试求网络地址。
	
解
	与一下就可以了
```

![](images02-01/01-09.jpg)

![](images02-01/01-10.jpg)

```
下面进一步讨论使用了子网掩码以后应怎样查找路由器。
```



### 2、使用子网时分组的转发

```
在划分子网的情况下，分组转发的算法必须做相应的改动。

我们应当注意到，使用子网划分后，路由表必须包含以下三项内容：
目的网络地址、子网掩码和下一跳地址。
```

```
在划分子网的情况下，路由器转发分组的算法如下：

1、从收到的数据报的首部提取目的IP地址D。
2、先判断是否为直接交付。
	对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和D逐位相"与"(AND操作)，看结果是否和相应的网络地址匹配。
	若匹配，则把分组进行直接交付(当然还需要把D转换成物理地址，把数据报封装成帧发送出去)，转发任务结束。
	否则就是间接交付，执行3。
	
3、若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器;
	否则，执行4。
	
4、对路由表中的每一行(目的网络地址，子网掩码，下一跳地址)，用其中的子网掩码和D逐位相"与"(AND操作)，其结果为N。
若N与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器;
否则，执行5.

5、若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器;否则执行6。

6、报告转发分组出错。
```



### 3、无分类编址 CIDR(构成超网)

#### 1、网络前缀

```
划分子网一定程度上缓解了因特网在发展中遇到的困难。
然后在1992年因特网仍然面临三个必须尽早解决的问题，这就是：
1、B类地址在1992年已分配了近一半，眼看很快就将全部分配完毕！

2、因特网主干网上的路由表中的项目急剧增长(从几千个增长到几万个)。

3、整个IPv4的地址空间最终将全部耗尽。在2011年2月3日，IANA宣布IPv4地址已经耗尽了。
```

```
当时预计前两个问题将在1994年变得非常严重。
因此IETF很快的就研究出采用  无分类编址 的方法来解决前两个问题。
IETF认为上面的第三个问题属于更加长远的问题，因此专门成立IPv6工作组负责研究解决新版本IP协议的问题。
```

```
其实早在1987年，RFC1009就指明了在一个划分子网的网络中可同时使用几个不同的子网掩码。
使用变长子网掩码VLSM(Variable Length Subnet Mask)可进一步提高IP地址资源的利用率。
在VLSM的基础上又进一步研究出无分类编址方法，它的正式名字是无分类遇见路由选择CIDR(Classless Inter-Domain Routing,CIDR的读音是 "sider")。

在1993年形成了 CIDR 的RFC文档：RFC1517~1519和RFC1520。
较新的CIDR文档是2006年发表的RFC4632，已把老的文档1519列为陈旧的。
```

```
CIDR最主要的特点有两个：
1、CIDR消除了传统的A类、B类和C类地址以及划分子网的概念，因而可以更加有效的分配IPv4的地址空间，并且可以在新的IPv6使用之前容许因特网的规模继续增长。

CIDR把32位的IP地址划分为两个部分。
前面的部分是"网络前缀"(network-prefix)(或简称为"前缀")，用来指明网络，后面的部分则用来指明主机。

因此CIDR(classless inter-domain routing)使IP地址从三级编址(使用子网掩码)又回到了两级编码，但这已是无分类的两级编址。
它的记法是：
```

![](images02-01/01-11.jpg)

```
CIDR 还使用"斜线记法"(slash notation),或称为CIDR记法，即在IP地址后面加上斜线"/"，然后写上网络前缀所占的位数。
```

```

2、CIDR把网络前缀都相同的连续IP地址组成一个"CIDR 地址块"。
我们只要知道CIDR地址块中的任何一个地址，就可以知道这个地址块的起始地址(即最小地址)和最大地址，以及地址块中的地址数。
```

![](images02-01/01-12.jpg)



```
当然，这两个主机号是全0和全1的地址一般并不使用。
通常只使用在这两个地址之间的地址。
不难看出，这个地址块共有2^12个地址。
我们可以用 地址块中的最小地址 和 网络前缀的位数 指明这个地址块。

例如，上面的地址块可记为 128.14.32.0/20。
不需要指出地址块的起始地址时，也可把这样的地址块简称为 "/20地址块"。
```

```
为了更方便的进行路由选择，CIDR使用32位的地址掩码(address mask)。
地址掩码由一串1和一串0组成，而1的个数就是网络前缀的长度。
虽然CIDR不使用子网了，但由于目前仍有一些网络还使用子网划分和子网掩码，因此CIDR使用的地址掩码也可继续称为子网掩码。

例如，/20地址块的地址掩码是：
11111111 11111111 11110000 00000000(20个连续的1)。

斜线记法中，斜线后面的数字就是地址掩码中1的个数。
```

```
请读者注意，"CIDR不使用子网"是指CIDR并没有在32位地址中指明若干位作为子网字段。
但分配到一个CIDR地址块的单位，仍然可以在本单位内根据需要划分出一些子网。
这些子网也都只有一个网络前缀和一个主机号字段，但子网的网络前缀比整个单位的网络前缀要长些。
例如，某单位分配到地址块/20，就可以再继续划分为8个子网(即需要从主机号中借用3位来划分子网)。
这时每一个子网的网络前缀就变成了23位(原来的20位加上从主机号借来的3位)，比该单位的网络前缀多了3位。
```

```
斜线记法还有一个好处就是它除了表示一个IP地址外，还提供了其他一些重要信息。
我们举例说明如下。
```

![](images02-01/01-13.jpg)

```
由于一个CIDR 地址块中有很多地址，所以在路由表中就利用CIDR地址块来查找目的网络。
这种地址的聚合常称为路由聚合(route aggregation), 它使得路由表中的一个项目可以表示原来传统分类地址的很多个(例如上千个)路由。
路由聚合也称为构成超网(supernetting)。

如果没有采用CIDR，则在1994和1995年，因特网的一个路由表就会超过7万个项目，而使用了CIDR后，在1996年一个路由表的项目才只有3万多个。
路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个因特网的性能。
```

```
CIDR记法有多种形式，例如，地址块10.0.0.0/10可简写为10/10,也就是把点分十进制中低位连续的0省略。
另一种简化表示方法是在网络前缀的后面加一个星号*，如：
00001010 00*

意思是：在星号*之前是网络前缀，而星号*表示IP地址中的主机号，可以是任意值。

前缀位数不是8的整数倍时，需要进行简单的计算才能得到一些地址信息。
```



![](images02-01/01-14.jpg)

```
从表4-7可看出，每一个CIDR地址块中的地址数一定是2的整数次幂。
除最后几行外，CIDR地址块都包含了多个C类地址(是一个C类地址的2^n倍，n是整数)，这就是"构成超网"这一名词的来源。
```

```
使用CIDR的一个好处就是可以更加有效的分配IPv4的地址空间，可根据客户的需要分配适当大小的CIDR地址块。
然而在分类地址的环境中，向一个组织分配IP地址，就只能以/8,/16或/24为单位来分配。这就很不灵活。
```



![](images02-01/01-15.jpg)

```
图4-25给出的是CIDR地址块分配的例子。
假定某ISP已拥有地址块 206.0.64.0/18(相当于有64个C类网络)。

现在某大学需要800个IP地址。
ISP可以给该大学分配一个地址块206.0.68.0/22，它包括1024(即2^10)个IP地址，相当于4个连续的C类/24地址块，占该ISP拥有的地址空间的1/16。

这个大学然后可自由地对本校的各系分配地址块，而各系还可再划分本系的地址块。
CIDR的地址块分配有时不易看清，这是因为网络前缀和主机号的界限不是恰好出现在整数字节处。
只要写出地址的二进制表示(从图中的地址块的二进制表示中可看出，实际上只需要将其中的一个关键字节转换为二进制的表示即可)，弄清网络前缀的位数，就不会把地址块的范围弄错。
```

```
从图4-25可以清楚的看出地址聚合的概念。
这个ISP共拥有64个C类网络。
如果不采用CIDR技术，则在该ISP的路由器交换路由信息的每一个路由器的路由表中，就需要有64个项目。
但采用地址聚合后，就只需用路由聚合后的一个项目206.0.64.0/18就能找到该ISP。

同理，这个大学共有4个系。
在ISP内的路由器的路由表中，也是需要使用206.0.68.0/22这一个项目。
```

```
从图4-25下面表格中的二进制地址可看出，把四个系的路由聚合为大学的一个路由(即构成超网)，是将网络前缀缩短。
网络前缀越短，其地址块所包含的地址数就越多。
而在三级结构的IP地址中，划分子网是使网络前缀变长。
```



#### 2、最长前缀匹配

```
在使用CIDR时，由于采用了网络前缀这种记法，IP地址由网络前缀和主机号这两个部分组成，因此在路由表中的项目也要有相应的改变。
这时，每个项目由"网络前缀"和"下一跳地址"组成。
但是在查找路由表时可能会得到不止一个匹配结果。
这样就带来一个问题：我们应当从这些匹配结果中选择哪一条路由呢?
```

```
正确的答案是：
应当从匹配结果中选择具有最长网络前缀的路由。
这叫做最长前缀匹配(longest-prefix matching),这是因为网络前缀越长，其地址块就越小，因而路由就越具体(more specific)。

最长前缀匹配又称为最长匹配或最佳匹配。
为了说明最长前缀匹配的概念，我们仍以前面的例子来讨论。
```

```
假定大学下属的四系希望ISP把转发给四系的数据报直接发到四系而不要经过大学的路由器，但又不愿意改变自己使用的IP地址块。

因此，在ISP的路由器的路由表中，至少要有以下两个项目，即206.68.0/22(大学)和206.0.71.128/25(四系)。

现在假定ISP收到一个 数据报，其目的IP地址为D=206.0.71.130。
把D分别和路由表中这两个项目的掩码逐位相"与"(AND操作)。
将所得的逐位AND操作的结果按顺序写在下面。
```

![](images02-01/01-16.jpg)

```
不难看出，现在同一个IP地址D可以在路由表中找到两个目的网络(大学和四系)和该地址相匹配。
根据最长前缀匹配的原理，应当选择后者，把收到的数据报转发到后一个目的网络(四系)，即选择两个匹配的地址中更具体的一个。
```

![](images02-01/01-17.jpg)



#### 3、使用二叉线索查找路由表

```
使用CIDR后，由于要寻找最长前缀匹配，使路由表的查找过程变得更加复杂了。
当路由表的项目数很大时，怎样设法减少路由表的查找时间就成为一个非常重要的问题。

例如，连接路由器的线路的速率为10Gb/s,而分组的平均长度为2000bit,那么路由器就应当平均每秒钟能够处理500万个分组(常记为5Mpps)。
或者说，路由器处理一个分组的平均时间只有200ns(1ns=10^-9秒)。
因此，查找每一个路由所需的时间应当是非常短的。
可见在路由表中必须使用很好的数据结构和使用先进的快速查找算法，这一直是人们积极研究的热门课题。
```

```
对无分类编址的路由表的最简单的查找算法就是对所有可能的前缀进行循环查找。
例如，给定一个目的地址D。
对每一个可能的网络前缀M，路由器从D中提取前M个位成一个网络前缀，然后查找路由表中的网络前缀。
所找到的最长匹配就对应于要查找的路由。

这种最简单的算法的明显缺点就是查找的次数太多。
最坏的情况是路由表中没有这个路由。
在这种情况下，算法仍要进行32次(具有32位的网络前缀是一个特定主机路由)。
就是要找到一个传统的B类地址(即/16)，也要查找16次。
对于经常使用的默认路由，这种算法都要经历31次不必要的查找。

int netAddr = 255.0.0.0;
int subnetMask = 0; 
for(int i = 32; i>=0; i++) {
	if(i > 0) {
		subnetMask &= (1<<(i-1));
	}
	int networkPrefix = netAddr & subnetMask;
	map.get(networkPrefix);
}
```



```
为了进行更加有效的查找，通常是把无分类编址的路由表存放在一种层次的数据结构中，然后自上而下的按层次进行查找。
这里最常用的就是 二叉线索(binary trie)，它是一种特殊结构的树。

IP地址中从左到右的比特值决定了从根节点逐层向下层延伸的路径，而二叉线索中的各个路径就代表路由表中存放的各个地址。
```

![](images02-01/01-18.jpg)

```
图4-26用一个例子来说明二叉线索的结构。
图中给出了5个IP地址。
为了简化二叉线索的结构，可以先找出对应于每一个IP地址的唯一前缀(unique prefix)。

所谓唯一前缀来构造二叉线索。
在进行查找时，只要能够和唯一前缀相匹配就行了。
```

```
从二叉线索的根节点自顶向下的深度最多有32层，每一层对应于IP地址中的一位。
一个IP地址存入二叉线索的规则很简单。
先检查IP地址左边的第一位，如为0，则第一层的节点就在根节点的左下方;
如为1，则在右下方。
然后再检查地址的第二位，构造出第二层的节点。
以此类推，直到唯一前缀的最后一位。

由于唯一前缀一般都小于32位，因此用唯一前缀构造的二叉线索的深度往往不到32层。

图中较粗的折线就是前缀0101在这个二叉线索中的路径。

二叉线索中的小圆圈是中间节点，而在路径终点的小方框是叶节点(也叫做外部节点)。
每个叶节点代表一个唯一前缀。
节点之间的连线旁边的数字表示这条边在唯一前缀中对应的比特是0或1。
```

```
假定有一个IP地址是 10011011 0111010 00000000 00000000，需要查找该地址是否在此二叉线索中。
我们从最左边查起。
很容易发现，查到第三个字符(即前缀10后面的0)时，在二叉线索中就找不到匹配的，说明这个地址不在这个二叉线索中。
```

```
以上只是给出了二叉线索这种数据结构的用法，并没有说明"与唯一前缀匹配"和"与网络前缀匹配"的关系。
一个唯一前缀匹配 != 网络前缀;
比如上图的4-26的第一个ip网络前缀
唯一前缀只有4个 0100
网络前缀有7个  01000110 00000000 00000000 00000000
找到了唯一前缀并不等于找到了网络前缀;

显然，要将二叉线索用于路由表中，还必须使二叉线索中的每一个叶节点包含所对应的网络前缀和子网掩码。
当搜索到一个叶节点时，就必须将寻找匹配的目的地址和该叶节点的子网掩码进行逐位"与"运算，看结果是否与对应的网络前缀相匹配。
若匹配，就按下一跳的接口转发该分组。否则，就丢弃该分组。
```

```
总之，二叉线索只是提供了一种可以快速在路由表中找到匹配的叶节点的机制。
但这是否和网络前缀匹配，还要和子网掩码进行一次逻辑与的运算。
```

```
为了提高二叉线索的查找速度，广泛使用了各种压缩技术。
例如，在图4-26中的最后两个地址，其最前面的4位都是1011。
因此，只要一个地址的前4位是1011，就可以跳过前面4位(即压缩了4个层次)而直接从第5位开始比较。
这样就可以减少查找的时间。
当然，制作经过压缩的二叉线索需要更多的计算，但由于每一次查找路由表时都可以提高查找速度，因此这样做还是值得的。
```



## 4、网际控制报文协议ICMP

```
为了更有效的转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP(Internet Control Message Protocol)。
ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。
ICMP是因特网的标准协议。

但ICMP不是高层协议(看起来好像是高层协议，因为ICMP报文时装在IP数据报中的，作为其中的数据部分)，而是IP层的协议。
ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。
ICMP报文格式如图4-27所示。
```

![](images02-01/01-19.jpg)



### 1、ICMP报文的种类

```
ICMP报文的种类有两种，即ICMP差错报告报文和ICMP询问报文。
```

```
ICMP(Internet Control Message Protocol)报文的前4个字节是统一的格式，共有三个字段：即类型、代码、检验和。
接着的4个字节的内容与ICMP的类型有关。
最后面的是数据字段，其长度取决于ICMP的类型。

表4-8给出了几种常用的ICMP报文类型。
```

![](images02-01/01-20.jpg)

| ICMP报文种类 | 类型的值 | ICMP报文                    |
| ------------ | -------- | --------------------------- |
| 差错报告报文 | 3        | 终点不可达                  |
|              | 4        | 源点抑制(Source quench)     |
|              | 11       | 时间超过                    |
|              | 12       | 参数问题                    |
|              | 5        | 改变路由(Redirect)          |
| 询问报文     | 8或0     | 回送(Echo)请求或回答        |
|              | 13或14   | 时间戳(Timestamp)请求或回答 |

```
现在已不再使用的ICMP报文有"信息请求与回答报文"、"地址掩码请求与回答报文"和"路由器请求与通告报文"，这些报文就没有出现在表4-8中。
```

```
ICMP报文的代码字段是为了进一步区分某种类型中的几种不同的情况。

检验和字段用来检验整个ICMP报文。
我们应当还记得，IP数据报首部的检验和并不检验IP数据报的内容，因此不能保证经过传输的ICMP报文不产生差错。
```

**ICMP差错报告报文共有五种，即：**

```
1、终点不可达 
	当路由器或主机不能交付数据报时就向源点发送终点不可达报文。

2、源点抑制
	当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。
	
3、时间超过
	当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。
	
4、参数问题
	当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。
	
5、改变路由(重定向)
	路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由)。
```

```
下面对改变路由报文进行简短的解释。
我们知道，在因特网的主机中也要有一个路由表。
当主机要发送数据报时，首先是查找主机自己的路由表，看应当从哪一个接口把数据报发送出去。
在因特网中主机的数量远大于路由器的数量，出于效率的考虑，这些主机不和连接在网络上的路由器定期交换路由信息。
在主机刚开始工作时，一般都在路由表中设置一个默认路由器的IP地址。
不管数据报要发送到哪个目的地址，都一律先将数据报传送给网络上的这个默认路由器，而这个默认路由器知道到每一个目的网络的最佳路由(通过和其他路由器交换路由信息)。

如果默认路由器发现主机 发往某个目的网络的最佳路由不应该经过默认路由器而是应当经过网络上的另一个路由器R时，就用改变路由报文把这情况告诉主机。
于是，该主机就在其路由表中增加一个项目：到某某目的地址应经过路由器R(而不是默认路由器)。
```

![](images02-01/01-21.jpg)

```
所有的 ICMP 差错报告报文中的数据字段都具有同样的格式(图4-28)。
把收到的需要进行差错报考的IP数据报的首部和数据字段的前8个字节提取出来，作为ICMP报文的数据字段。

再加上相应的ICMP(internet Control Message Protocol)差错报文的前8个字节，就构成了ICMP差错报文。

提取收到的数据报的数据字段的前8个字节是为了得到运输层的端口号(对于TCP和UDP)以及运输层报文的发送序号(对于TCP)。

这些信息对源点通知高层协议是有用的。
整个ICMP报文作为IP数据报字段发送给源点。
```

```
下面是不应发送ICMP差错报告报文的几种情况：
	1、对ICMP差错报告报文不再发送ICMP差错报文。
	2、对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。
	3、对具有多播地址的数据报都不发送ICMP差错报告报文。
	4、对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文。
```

```
常用的ICMP询问报文有两种，即：
1、回送请求和回答
	ICMP 回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。
	收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。
	这种询问用来测试目的站是否可达以及了解其有关状态。
	
	
2、时间戳请求和回答
	ICMP时间戳请求报文时请某个主机或路由器回答当前的日期和时间。
	在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。
	时间戳请求与回答可用来进行时钟同步和测量时间。
```



### 2、ICMP的应用举例

**PING**

```
ICMP的一个重要应用就是分组探测 PING(Packet InterNet Groper),用来测试两个主机之间的连通性。
PING使用了ICMP回送请求与回答报文。
PING是应用层直接使用网络层ICMP的一个例子。
它没有通过运输层的TCP或UDP。
```

```
Windows 操作系统的用户可在接入因特网后转入MS DOS(就是cmd)。

看见屏幕上的提示符后，就键入 ping hostname, 按回车键就可看到结果。
```

![](images02-01/01-22.jpg)

```
图4-29给出了从南京的一台PC到新浪网的邮件服务器 mail.sina.com.cn 的连通性的测试结果。
PC一连发出四个ICMP回送请求报文。
如果邮件服务器 mail...... 正常工作而且响应这个ICMP回送请求报文(有的主机为了防止恶意攻击就不理睬外界发送过来的这种报文)。

那么它就发回ICMP回送回答报文。
由于往返的ICMP报文上都有时间戳，因此很容易得出往返时间。

最后显示出的结果：发送到哪个机器(IP地址)，发送的、收到的和丢失的分组数(但不给出分组丢失的原因)。往返时间的最小值、最大值和平均值。
从得到的结果可以看出，第三个测试分组丢失了。
```



**Traceroute**

```
另一个非常有用的应用是 tracetoute(这是UNIX操作系统中名字)，它用来跟踪一个分组从源点到终点的路径。
在Windows 操作系统中这个命令是 tracert。
下面简单介绍这个程序的工作原理。
```

```
Traceroute 从源主机向目的主机发送一连串的IP数据报，数据报中封装的是无法交付的UDP用户数据报。(比如使用非法端口号)

第一个数据报P1的生存时间TTL设置为1。
当P1到达路径上的第一个路由器R1时，路由器R1先收下它，接着把TTL的值减1。
由于TTL等于零了，R1就把P1丢弃了，并向源主机发送一个ICMP时间超过差错报告报文。

源主机急着发送第二个数据P2，并把TTL设置为2.
P2先到达路由器R1,R1收下后把TTL减1再转发给路由器R2。
R2收到P2时TTL为1，但减1后TTL变为零了。
R2就丢弃P2,并向源主机发送一个ICMP时间超过差错报告报文。
这样一直继续下去。
当最后一个数据报刚刚到达目的主机时，数据报的TTL是1。

主机不转发数据报，也不把TTL值减1。
但因IP数据报中封装的是无法交付的运输层的UDP用户数据报，因此目的主机要向源主机发送ICMP终点不可达差错报告报文。
```

```
这样，源主机达到了自己的目的，因此这些路由器和最后目的主机发来的ICMP报文正好给出了源主机想知道的路由信息 -- 到达目的主机所经过的路由器的IP地址，以及到达其中的每一个路由器的往返时间。
```

![](images02-01/01-23.jpg)



```
我们还应注意到，从原则上讲，IP数据报经过的路由器越多，所花费的时间也会越多。
但从4-30可看出，有正好相反。

这是因为因特网的拥塞程度随时都在变化，也很难预料到。
因此，完全有这样的可能：经过更多的路由器反而花费更少的时间。
```



## 5、因特网的路由选择协议

本节将讨论几种常用的路由选择协议，也就是讨论路由表中的路由是怎样得出的。

### 1、有关路由选择协议的几个基本概念

#### 1、理想的路由算法

```
路由选择协议的核心就是路由算法，即需要何种算法来获得路由表中的各项目。
一个理想的路由算法应具有如下的一些特点：

1、算法必须是正确的和完整的。
	这里，“正确”的含义是：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机。
	
2、算法在计算上应简单。
	路由选择的计算不应使网络通信量增加太多的额外开销。
	
3、算法应能适应通信量和网络拓扑的变化，这就是说，要有自适应性。
	当网络中的通信量发生变化时，算法能自适应的改变路由以均衡各链路的负载。
	当某个或某些节点、链路发生故障不能工作，或者修理好了再投入运行时，算法也能及时改变路由。有时称这种自适应性为"稳健性(robustness)"。
	
4、算法应具有稳定性。
	在网络通信量和网络拓扑相对稳定的情况下，路由算法应收敛于一个可以接受的解，而不应使得出的路由不停得变化。
	
5、算法应是公平的。
	路由选择算法应对所有用户(除对少数优先级高的用户)都是平等的。
	例如，若仅仅使某一对用户的端到端时延为最小，但却不考虑其他的广大用户，这就明显的不符合公平性的要求。

6、算法应是最佳的
	路由选择算法应当能够找到最好的路由，使得分组平均时延最小而网络的吞吐量最大。
	虽然我们希望得到"最佳"的算法，但这并不总是最重要的。
	对于某些网络，网络的可靠性有时要比 最小的分组平均时延或最大吞吐量更加重要。
	因此，所谓"最佳"只能是相对于某一种特定要求下得出的较为合理的选择而已。
```

```
实际上一个路由选择算法，应尽可能接近于理想的算法。
在不同的应用条件下，对以上提出的六个方面也可能有不同的侧重。

应当指出，路由选择是个非常复杂的问题，因为它是网络中的所有结点共同协调工作的结果。
其次， 路由选择的环境往往是不断变化的，而这种变化有时无法事先知道，例如，网络中除了某些故障。
此外，当网络发生拥塞时，就特别需要有能缓解这种拥塞的路由选择策略，但恰好在这种条件下，很难从网络的各节点获得所需的路由选择信息。
```

![](images02-01/01-24.jpg)



#### 2、分层次的路由选择协议

```
因特网采用的路由选择协议主要是自适应的(即动态的)、分布式路由选择协议。
由于以下两个原因，因特网采用分层次的路由选择协议：

1、因特网的规模非常大。
	如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。
	而所有这些路由器之间交换路由信息所需的带宽就会使因特网的通信链路饱和。
	
2、许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议(这属于本部门内部的事情)，但同时还希望连接到因特网上。


为此，因特网将整个互联网划分为许多较小的自治系统(autonomous system), 一般都记为AS。
RFC 4271 对自制系统AS有下面这样的描述：
---自治系统AS的经典定义是在单一的技术管理下的一组路由器，

而这些路由器使用一种AS内部的路由选择协议和共同的度量，以确定分组在该AS内的路由;
同时还使用一种AS之间的路由选择协议，用以确定分组在AS之间的路由。

自从有了这个经典定义后，使用多种内部路由选择协议和多种度量的AS也是很常见的。

因此，现在对自治系统AS的定义是强调下面的事实：尽管一个AS使用了多种内
部路由选择协议和度量，但重要的是一个AS对其他AS表现出的是一个单一的一致的路由选择策略。
```

```
在目前的因特网中，一个大的ISP就是一个自治系统。
这样，因特网就把路由选择协议划分为两大类，即：

1、内部网关协议IGP(Interior Gateway Protocol) 
	即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。
	目前这类路由选择协议用的最多的是，如RIP何OSPF协议。

2、外部网关协议EGP(External Gateway Protocol)
	若源主机和目的主机处在不同的自制系统中(这两个自治系统可能使用不同的内部网关协议)，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自制系统中。
	这样的协议就是外部网关协议 EGP。
	目前使用最多的外部网关协议是BGP的版本4(BGP-4)。
```

```
自治系统之间的路由选择也叫做域间路由选择(interdomain routing)，

而在自治系统内部的路由选择叫做域内路由选择(intradomain routing)。
```

![](images02-01/01-25.jpg)

```
图4-31是两个自治系统互联在一起的示意图。
每个自治系统自己决定在本自治系统内部运行哪一个内部路由选择协议(例如，可以是RIP，也可以是OSPF)。
但每个自治系统都要有一个或多个路由器除运行本系统的内部路由选择协议之外，还要运行自治系统间的路由选择协议(BGP-4)。
```

```
这里我们要指出两点：

1、因特网的早期RFC文档中未使用"路由器"而是使用"网关"这一名词。
但是在新的RFC文档中又使用了"路由器"这一名词，因此有的书把IGP和EGP分别改为 IRP(内部路由器协议)和ERP(外部路由器协议)。
为了方便读者查阅RFC文档，本书仍使用RFC原先使用的名字。IGP(interior Gateway Protocol) 和 EGP(external Gateway protocol)。


2、RFC采用的名词IGP和 EGP 是协议类别的名称。
但RFC在使用名词EGP时出现了一点混乱，因为最早的一个外部网关协议的协议名字正好也是EGP。
后来RFC提出的EGP有不少缺点，就这几了一种更好的外部网关协议，叫做边界网关协议BGP(Border Gateway Protocol),用来取代旧的RFC827外部网关协议EGP。
实际上，旧协议EGP和新协议BGP都属于外部网关协议 EGP 这一类别。
因此在遇到名词 EGP时，应弄清它是指旧协议EGP(即RFC827)还是指外部网关协议EGP这个类别。

总之，使用分层次的路由选择方法，可将因特网的路由选择协议划分为：
内部网关协议IGP：具体的协议有多种，如RIP何OSPF等。
外部网关协议EGP：目前使用的协议就是BGP。


对于比较大的自治系统，还可将所有的网络再进行一次划分。
例如，可以构筑一个链路速率较高的主干网和许多速率较低的区域网。
每个区域通过路由器连接到主干网。
在一个区域内找不到目的站时，就通过路由器经过主干网到达另一个区域网，或者通过外部路由器到别的自治系统中去查找。
下面对这两类协议分别进行介绍。
```



### 2、内部网关协议RIP

#### 1、工作原理

```
RIP(Routing Information Protocol)是内部网关协议 IGP 中最先得到广泛使用的协议，它的中文名称很少使用，叫做路由信息协议。

RIP是一种分布式的基于距离向量的路由选择协议，是因特网的标准协议，其最大优点就是简单。
```

```
RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录(因此，这是一组距离，即"距离向量")。
RIP协议将 "距离"定义如下：

从一路由器到直接连接的网络的距离定义为1。
从以路由器到非直接连接的网络的距离定义为所经过的路由器数加1。
"加1"是因为到达目的网络后就进行直接交付，而到直接连接的网络的距离已经定义为1。
```

```
RIP协议的"距离"也称为"跳数"(hop count)，因为每经过一个路由器，跳数就加1。
RIP认为好的路由就是它通过的路由器的数目少，即"距离短"。
RIP允许一条路径最多只能包含15个路由器。
因此"距离"等于16时即相当于不可达。
可见RIP只适用与小型互联网。
```

![](images02-01/01-26.jpg)

```
RIP不能在两个网络之间同时使用多条路由。
RIP选择一条具有最少路由器的路由(即最短路由)，哪怕还存在另一条高速(低时延)但路由器较多的路由。
```

```
本节讨论的RIP协议和下一节要讨论的OSPF协议，都是分布式路由选择协议。
它们的共同特点就是每一个路由器都要不断的和其他一些路由器交换路由信息。

我们一定要弄清以下三个要点，即和
哪些路由交换信息？
交换什么信息？
在什么时候交换信息？
```

```
RIP协议的特点是：
1、仅和相邻路由器交换信息。
	如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。RIP协议规定，不相邻的路由器不交换信息。
	
2、路由器交换的信息是 当前本路由器所知道的全部信息，即自己的路由表。
也就是说，交换的信息是："我到本自治系统中所有网络的(最短)距离"，以及到每个网络应经过的下一跳路由器"。

3、按固定的时间间隔交换路由信息，例如，每隔30秒。
然后路由器根据收到的路由信息更新路由表。
当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。(这个触发更新不太懂)
```

```
这里要强调一点：路由器在刚刚开始工作时，只知道到直接连接的网络的距离(此距离定义为1)。

接着，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。
但经过若干次的更新后，所有的路由器最终都会知道到达自治系统中任何一个网络的最短距离和下一跳路由器的地址。

看起来RIP协议有些奇怪，因为"我的路由表中的信息要依赖于你的，而你的信息又依赖于我的"。
然而事实证明，在一般情况下，RIP协议可以收敛(convergence),并且过程也较快。

"收敛"就是在自治系统中所有的结点都得到正确的路由选择信息的过程。
```

```
路由表中最主要的信息就是：到某个网络的距离(即最短距离)，以及应经过的下一跳地址。
路由表更新的原则是找出到每个目的网络的最短距离。
这种更新算法又称为距离向量算法。
下面就是RIP协议使用的距离向量算法。
```

#### 2、距离向量算法

```
对每一个相邻路由器发送过来的RIP报文，进行以下步骤：

1、对地址为X的相邻路由器发来的RIP报文，先修改此报文中的所有项目：
	把"下一跳"字段中的地址都改为X,并把所有的"距离"字段的值加1(见后面的解释1)。
	每个项目都有三个关键数据，即：到目的网络N，距离是d，下一跳路由器是X。
	
2、对修改后的RIP报文中的每一个项目，进行以下步骤：
若原来的路由表中没有目的网络N，则把该项目添加到路由表中(见解释2)。
	否则(即在路由表中有目的网络N，这时就再查看下一跳路由器地址)
若下一跳路由器地址是X，则把收到的项目替换原路由表中的项目(见解释3)。
	否则(即这个项目是，到目的网络N，但下一跳路由器不是X)，
若收到的项目中的距离d小于路由表中的距离，则进行更新(见解释4)，
否则什么也不做(见解释5)。

3、若三分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器标记为不可达的路由器，即把距离置为16(距离为16表示不可达)。

4、返回

上面给出的距离向量算法的基础就是 Bellman-Ford算法(或 Ford-Fulkerson算法)。
这种算法的要点是这样的：
设X是结点A到B的最短路径上的一个结点。
若把路径A->B拆成两段路由 A->X 和 X->B,
则每一段路径 A->X 和 X->B 也都分别是节点A到X和节点x到B的最短路径。
```

```
下面是对上述距离向量算法的五点解释。

解释1：这样做事为了便于进行本路由表的更新。
假设从位于地址X的相邻路由器发来的RIP报文的某一个项目是 "Net2,3,Y",
意思是"我经过路由器Y到网络Net2的距离是3"，那么本路由器就可推断出："我经过X到网络Net2的距离应为3+1=4"。
于是，本路由器就把收到的RIP报文的这一个项目修改为 "Net2,4,X",作为下一步和路由表中原有项目进行比较时使用(只有比较后才能知道是否需要更新)。
读者可注意到，收到的项目中的Y对本路由器是没有用的，因为Y不是本路由器的下一跳路由器地址。

解释2：表明这是新的目的网络，应当加入路由表中。

解释3:为什么要替换呢？因为这是最新的消息，要以最新的消息为准。
到目的网络的距离有可能增大或减小，但也可能没有改变。
--因为你目的网络和下一跳网络都是一样的只有距离不一样,当然要以最新的为准。

解释4：目的网络一样，下一跳的网络不一样，就取跳数最少的作为新的路由表项。

解释5：如果距离变大了，当然不更新了。
```

![](images02-01/01-27.jpg)

![](images02-01/01-28.jpg)

![](images02-01/01-29.jpg)

```
RIP协议让一个自治系统中的所有路由器都和自己相邻路由器定期交换路由信息，并不断更新其路由表，使得每一个路由器到每一个目的网络的路由都是最短的(即跳数最少)。
这里还应注意：虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。
```



#### 3、RIP协议的报文格式

```
现在较新的RIP版本是1998年11月公布的RIP2，新版本协议本身并无多大变化，但性能上有些改进。
RIP2可以支持变长子网掩码和无分类域间路由选择CIDR。
此外，RIP2还提供简单的鉴别过程支持多播。
```

![](images02-01/01-30.jpg)

```
图4-32是RIP2的报文格式，它和RIP1的首部相同，但后面的路由部分不一样。
从图4-32还可看出，RIP协议使用运输层的用户数据报UDP进行传送(使用UDP端口 520)。
```

```
RIP报文由首部和路由部分组成。
RIP的首部占4个字节，其中的命令字段指出报文的意义。
例如，1表示请求路由信息，
2表示对请求路由信息的响应或未被请求而发出的路由更新报文。
首部后面的"必为0"是为了4字节字的对齐。
```

```
ROP2报文中的路由部分由若干个路由信息组成。
每个路由信息需要用20个字节。
地址族标识符(又称为地址类别)字段用来标志所使用的地址协议。
如采用IP地址就令整个字段的值为2(原来RIP也可用于其他非TCP/IP协议的情况)。
路由标记填入自治系统号ASN(Autonomous System Number),这是考虑使RIP有可能收到本自治系统以外的路由选择信息。

再后面指出某个网络地址、该网络的子网掩码、下一跳路由地址以及到此网络的距离。
一个RIP报文最多可包括25个路由，因而RIP报文的最大长度是 4+20*25 = 504 字节。
如超过，必须再用一个RIP报文来传送。
```

```
RIP2还具有简单的鉴别功能。
若使用鉴别功能，则将原来写入第一个路由信息(20字节)的位置用作鉴别。
这时应当将地址族标识符置为全1(即0xFFFF),而路由标记写入鉴别类型，剩下的16字节为鉴别数据。
在鉴别数据之后才写入路由信息，但这时最多只能再放入24个路由信息。
```

![](images02-01/01-31.jpg)

```
RIP存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。
我们可以用图4-33的简单例子来说明。
设三个网络通过两个路由器互连起来，并且都已经建立各自的路由表。
图中路由器交换的信息只给出了我们感兴趣的一行内容。
路由器R1中的"1,1,直接"表示"到网1的距离是1，直接交付"。
路由器R2中的"1,2,R1"。
```

```
现在假定路由器R1到网1的链路出了故障，R1无法到达网1。
于是路由器R1把到网1的距离改为16(表示网1不可达)，因而在R1的路由表中的相应项目变为"1,16,直接"。
但是，很可能要经过30秒后R1才把更新信息发送给R2。
然后R2可能已经先把自己的路由表发送给了R1,其中"1,2,R1"这一项。
```

```
R1收到R2的更新报文后，误认为可经过R1到达网1，于是把收到的路由信息"1,2,R1"修改为："1,3,R2"，表明"我到网1的距离是3，下一跳经过R2"，并把更新后的信息发送给R2。

同理，R2接着又更新自己的路由表为"1,4,R1",以为"我到网1距离是4，下一跳经过R1"。

这样的更新一直继续下去，知道R1和R2到网1的距离都增大到16时，R1和R2才知道原来网1是不可达的。RIP协议的这一特点叫做：好消息传播的快，而坏消息转播的慢。

网络出故障的传播时间往往需要较长的时间(例如数分钟)。
这是RIP的一个主要缺点。
```

```
但如果一个路由器发现了更短的路由，那么这种更新信息就传播的很快。

为了使坏消息传播的更快些，可以采取多种措施。
例如，让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送。
```

```
总之，RIP协议最大的优点就是实现简单，开销较小。
但RIP协议的缺点也较多。
首先，RIP限制了网络的规模，它能使用的最大距离为15(16表示不可达)。
其次，路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。
最后，"坏消息传播得慢"，使更新过程的收敛时间过长。
因此，对于规模较大的网络就应当使用下一节所述的 OSPF 协议。

然而目前在规模较小的网络中，使用RIP协议的仍占多数。
```

















