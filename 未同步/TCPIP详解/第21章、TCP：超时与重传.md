# 21 TCP的超时与重传

## 1、tcp协议中的RTO的计算

```
TCP超时与重传中一个最重要的部分是对一个给定连接的往返时间(RTT)的测量。由于网络流量的变化，这个时间会相应的发生变化，TCP需要跟踪这些变化并动态调整超时时间RTO。

RTT(Round Trip Time)由三部分组成：链路的传播时间(propagation delay),末端系统的处理时间，路由器缓存中的排队和处理时间(queuing delay).

链路的传播时间
末端系统的处理时间
路由器缓存中的排队和处理时间

其中，前两个部分的值对于一个TCP连接相对固定，路由器缓存中的排队和处理时间会随着整个网络拥塞程度的变化而变化。所以RTT的变化在一定程序上反应了网络的拥塞程度。
```



```
TCP协议中经常会发生超时重传的情况，我们知道超时重传中的"时"是即RTO. RTO是Retransmission Timeout 的缩写，该时间决定了发送方在发送数据后，在多长时间内如果没有收到ACK，就重置重传计时器，并重传上次发送失败的报文。那么RTO是如何计算的呢？

RTO说白了就是根据RTT(往返时延)而确定的。但是我们知道，RTT是一个不确定的数值，因为TCP以下的网络层相当负责，每个报文发送出去的RTT不一定相同。这样就使得RTO的计算也比较难。为了给出一个比较合理的RTO。我们需要采用统计学里面的一些方法。首先我们介绍几个RTT变量，分别是 RTTm(测量RTT)，RTTs(平滑RTT)，RTTD(偏差RTT).

RTTm：m可以看成 measure(测量)的缩写，他是本次时间测量的RTT值，当然本次测量不能代表着一个绝对正确的值。
 注意： 关于测量RTTm(measure)的获取，我们可以有不同的方法。我们可以在发送端设置计时器，也可以在发送的TCP报文选项中添加时间戳选项，用于记录发送时间，接收方接到该报文后，把该发送时间从报文中复制到ACK报文发回给发送端。所有，RTTm(measure)的计算方法并不唯一。
 
RTTs : s 是 Smoothed(平滑)的缩写，我们可以把RTTs(smoothed)看成一个平均的RTT，相当于一个累积的RTT的期望值，它不仅考虑本次测量的RTT值，还会吸取历史经验，考虑以前的RTT的值，且之前的RTT的值占的比重远高于本次测量的RTT(即RTTm(measure)).所以，RTTm(measure) 本次测到的RTT只是整体RTTs(smoothed)的一个样本。
注意：我们可以将RTTs看成RTT的一个平均值(或期望值)

RTTD: D是 Deviation(偏差)的缩写，偏差说白了就是误差值，它也是一个经验累加值。跟RTTm(measure)一样，它会将之前采用的 RTTD作为一个参考，同时加上当前的偏差
注意：偏差我们可以看做是测量值与平均值(或期望值)之差的绝对值。所以本次RTTD=|RTTm-RTTs|   deviation measure smoothed
```



```
RTP:RTO主要考虑RTT的期望值和偏差
综上的理解，我们就可以很快理解并记住一下公式。
第一次测量时候，RTTm是我们测量的结果，RTTs=RTTm,RTTD=RTTm/2

以后每次测量采用以下公式
	RTTs=(1-a)*RTTs+a*RTTm, a通常为1/8,即0.125 ...... 公式1
	RTTD=(1-b)*RTTD+b*|RTTm-RTTs|, b通常为1/4,即0.25 ...... 公式2
	RTO = RTTs+4RTTD ...... 公式3
	
	说明：公式3不管是第一次计算还是最后一次，都是采用该公式。
	
```

```
FAQ(常见问题解答)：假设发送端发送一个报文后，在RTO内没有收到ACK，发送端重传该报文，并重置计时器。后来发送端收到了ACK，但是发送端比较困惑的是该报文的ACK是之前发送的报文段对应的ACK(可能在网络中呆了很长时间)还是本次发送的报文对应的ACK，由于这个事实不能确定，所以本次获得的RTTm是不准确的，那如何更新RTO呢？

方法一：放弃考虑本次获得的RTTm, 因为我们无法测得一个准确的信息(即该ACK到底对应哪个报文)，该处理方法称之为 Karn 算法。很明显，该算法的缺点是没有考虑本次测量值，例如，为什么会要求重传？如果不是网络不拥挤会要求重传吗？这些问题都被简单的抛弃了。


方法二：考虑到方法一的缺点和优点，通常采取的做法是：不考虑获取的RTTm,因为不确定是否正确(这是利用Karn算法的优点)，同时每发生一次重传，RTO就加倍，即RTO=2*RTO(弥补了Karn算法的不足)，该方法称为 指数退避。
```



























