# 21 TCP的超时与重传

## 1、tcp协议中的RTO的计算

```
TCP超时与重传中一个最重要的部分是对一个给定连接的往返时间(RTT)的测量。由于网络流量的变化，这个时间会相应的发生变化，TCP需要跟踪这些变化并动态调整超时时间RTO。

RTT(Round Trip Time)由三部分组成：链路的传播时间(propagation delay),末端系统的处理时间，路由器缓存中的排队和处理时间(queuing delay).

链路的传播时间
末端系统的处理时间
路由器缓存中的排队和处理时间

其中，前两个部分的值对于一个TCP连接相对固定，路由器缓存中的排队和处理时间会随着整个网络拥塞程度的变化而变化。所以RTT的变化在一定程序上反应了网络的拥塞程度。
```



```
TCP协议中经常会发生超时重传的情况，我们知道超时重传中的"时"是即RTO. RTO是Retransmission Timeout 的缩写，该时间决定了发送方在发送数据后，在多长时间内如果没有收到ACK，就重置重传计时器，并重传上次发送失败的报文。那么RTO是如何计算的呢？

RTO说白了就是根据RTT(往返时延)而确定的。但是我们知道，RTT是一个不确定的数值，因为TCP以下的网络层相当负责，每个报文发送出去的RTT不一定相同。这样就使得RTO的计算也比较难。为了给出一个比较合理的RTO。我们需要采用统计学里面的一些方法。首先我们介绍几个RTT变量，分别是 RTTm(测量RTT)，RTTs(平滑RTT)，RTTD(偏差RTT).

RTTm：m可以看成 measure(测量)的缩写，他是本次时间测量的RTT值，当然本次测量不能代表着一个绝对正确的值。
 注意： 关于测量RTTm(measure)的获取，我们可以有不同的方法。我们可以在发送端设置计时器，也可以在发送的TCP报文选项中添加时间戳选项，用于记录发送时间，接收方接到该报文后，把该发送时间从报文中复制到ACK报文发回给发送端。所有，RTTm(measure)的计算方法并不唯一。
 
RTTs : s 是 Smoothed(平滑)的缩写，我们可以把RTTs(smoothed)看成一个平均的RTT，相当于一个累积的RTT的期望值，它不仅考虑本次测量的RTT值，还会吸取历史经验，考虑以前的RTT的值，且之前的RTT的值占的比重远高于本次测量的RTT(即RTTm(measure)).所以，RTTm(measure) 本次测到的RTT只是整体RTTs(smoothed)的一个样本。
注意：我们可以将RTTs看成RTT的一个平均值(或期望值)

RTTD: D是 Deviation(偏差)的缩写，偏差说白了就是误差值，它也是一个经验累加值。跟RTTm(measure)一样，它会将之前采用的 RTTD作为一个参考，同时加上当前的偏差
注意：偏差我们可以看做是测量值与平均值(或期望值)之差的绝对值。所以本次RTTD=|RTTm-RTTs|   deviation measure smoothed
```



```
RTP:RTO主要考虑RTT的期望值和偏差
综上的理解，我们就可以很快理解并记住一下公式。
第一次测量时候，RTTm是我们测量的结果，RTTs=RTTm,RTTD=RTTm/2

以后每次测量采用以下公式
	RTTs=(1-a)*RTTs+a*RTTm, a通常为1/8,即0.125 ...... 公式1
	RTTD=(1-b)*RTTD+b*|RTTm-RTTs|, b通常为1/4,即0.25 ...... 公式2
	RTO = RTTs+4RTTD ...... 公式3
	
	说明：公式3不管是第一次计算还是最后一次，都是采用该公式。
--------------------------------------------	
	也可以这样 两个公式之间可一互相转换
	RTTs=(1-a)*RTTs+a*RTTm
	= RTTs - a*RTTS + a*RTTm
	= RTTs + (a*RTTm - a*RTTs);
	= RTTs + a*(RTTm - RTTs);
	
	RTTD=(1-b)*RTTD+b*|RTTm-RTTs|
	= RTTD-b*RTTD + b*|RTTm-RTTs|
	= RTTD+(b*|RTTm-RTTs|- b*RTTD)
	= RTTD + b*(|RTTm-RTTs|-RTTD);
	
	RTTs + a*(RTTm - RTTs);
	RTTD + b*(|RTTm-RTTs|-RTTD);
	可以变为
	-------------------------------------
	最终：
	Err = RTTm-Rtts;
	RTTs = RTTs + a* Err;
	RttD = b*(|Err| - RTTD);
	RTO = RTTs + 4*RTTD;
	
	
	s = smoothed(平滑的)
	m = measure(测量)
	D = diviation(偏差)
```

```
FAQ(常见问题解答)：假设发送端发送一个报文后，在RTO内没有收到ACK，发送端重传该报文，并重置计时器。后来发送端收到了ACK，但是发送端比较困惑的是该报文的ACK是之前发送的报文段对应的ACK(可能在网络中呆了很长时间)还是本次发送的报文对应的ACK，由于这个事实不能确定，所以本次获得的RTTm是不准确的，那如何更新RTO呢？

方法一：放弃考虑本次获得的RTTm, 因为我们无法测得一个准确的信息(即该ACK到底对应哪个报文)，该处理方法称之为 Karn 算法。很明显，该算法的缺点是没有考虑本次测量值，例如，为什么会要求重传？如果不是网络不拥挤会要求重传吗？这些问题都被简单的抛弃了。


方法二：考虑到方法一的缺点和优点，通常采取的做法是：不考虑获取的RTTm,因为不确定是否正确(这是利用Karn算法的优点)，同时每发生一次重传，RTO就加倍，即RTO=2*RTO(弥补了Karn算法的不足)，该方法称为 指数退避。‘

这里的指针退避只加倍了 RTO 所以一旦正常，又会根据 RTTs,RTTd,RTTm 重新计算RTO。
```



## 1、引言

```
TCP提供可靠的运输层。它使用的方法之一就是确认从另一端收到的数据。但数据和确认都有可能会丢失。TCP通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到确认，它就重传该数据。对任何实现而言，关键之处就在于超时和重传的策略，即怎样确定超时间隔和如何确定重传的频率
```

```
对于每个连接，TCP管理4个不同的定时器。
1、重传定时器使用于当希望收到另一端的确认。发送数据到收到ack的时间定时器
2、坚持(persist)定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。
3、保活(keepalive)定时器可检测到一个空闲连接的另一端何时崩溃或重启。
4、2MSL定时器测量一个连接处于TIME_WAIT状态的时间。

本章以一个简单的TCP超时和重传的例子开始，然后转向一个更复杂的例子。该例子可以使我们观察到TCP时钟管理的所有细节。可以看到TCP的典型实现是怎样测量TCP报文段的往返时间以及TCP如何使用这些测量结果来为下一个将要传输的报文段建立重传超时时间。
接着我们将研究TCP的拥塞避免 -- 当分组丢失时TCP所采取的动作 -- 并提供一个分组丢失的实际例子，
我们还将介绍较新的快速重传和快速恢复算法，并介绍该算法如何使TCP检测分组丢失比等待时钟超时更快。
```





## 2、超时与重传的简单例子

```
首先观察TCP所使用的重传机制，我们将建立一个链接，发送一些分组来证明一切正常，然后拔掉电缆，发送更多的数据，再观察TCP行为。
```

![](images21/01-01.jpg)



下图表示的是tcpdump的输出结果（已经去掉了bsdi设置的服务类型信息）。 

![](images21/01-02.jpg)

```
第1、2和3行表示正常的TCP连接建立的过程，第4行是“hello,world”（12个字符加上回车和换行）的传输过程，第5行是其确认。接着我们从svr4拔掉了以太网电缆，第6行表示“and hi”将被发送。第7~18行是这个报文段的12次重传过程，而第19行则是发送方的TCP最终放弃并发送一个复位信号的过程.
```

```
现在检查连续重传之间不同的时间差，它们取整后分别为 1、3、6、12、24、48和多个64.在本章的后面，我们将看到当第一次发送后所设置的超时时间实际上为1.5秒(它在首次发送后的1.0136秒而不是精确的1.5秒后，因为定时器的第一个会在0-500ms时间同步至内核的时间，和内核的溢出时间一致，如果为230，溢出为300,那就再过70ms就相当于第一个300，以后就根据内核的300溢出就可以确定定时器的溢出)。此后该时间在每次重传时增加1倍并直至64秒。

这个倍乘关系被称为"指数退避(exponential backoff)"。

首次分组传输(第6行，24.480秒)与复位信号传输（第19行，566.488秒）之间的时间差约为9分钟，该时间在目前的TCP实现中是不可变的。

对于大多数实现而言，这个总时间是不可调整的。Solaris 2.2允许管理者改变这个时间（E.4节中的tcp_ip_abort_interval变量），且其默认值为2分钟，而不是最常用的9分钟。
```

## 3、往返时间测量

```
TCP超时与重传中最重要的部分就是对一个给定连接的往返时间(RTT)的测量。由于路由器和网络流量均会变化，因此我们认为这个时间可能经常会发生变化，TCP应该跟踪这些变化并相应的改变其超时时间。

首先TCP必须测量在发送一个带有特别序号的字节和接收到包含该字节的确认之间的RTT。在上一章中，我们曾提到在数据报文段和ACK之前通常并没有一一对应的关系。在图20.1中，这意味着发送方可以测量到的一个RT T，是在发送报文段4（第1~1024字节）和接收报文段7（对1~1024字节的ACK）之间的时间，用RTTM(measure)表示所测量到的RTT。
```

```
算法在xx.md的开头

RTTm(measure)
RTTs(smoothed)
RTTD(diviation)

RTTs =(1-a)RTTs + a*RTTm
RTTD = (1-b)RTTD + b*|RTTm - RTTs|
RTO = RTTs + 4RTTD;

偏差我们可以看做是测量值与平均值(或期望值)之差的绝对值。所以本次RTTD=|RTTm-RTTs|  
偏差是测量值和平均值之差的绝对值

第一次 RTTs = RTTm
RTTD = RTTm/2
RTO = RTTs + 4RTTD
```

### karn算法

```
在一个分组重传时会产生这样一个问题：假定一个分组被发送。当超时发生时候，RTO正如显示的那样进行退避，分组以更长的RTO进行重传，然后收到一个确认。那么这个ACK是针对第一个分组的还是针对第二个分组呢？这就是所谓的重传多义性问题。

[Karn and Partridge 1987]规定，当一个超时和重传发生时，在重传数据的确认最后到达之前，不能更新RTT估计器，因为我们并不知道ACK对应哪次传输(也许第一次传输被延迟而并没有被丢弃，也有可能第一次传输的ACK被延迟)。

并且，由于数据被重传，RTO已经得到了一个指数退避，我们在下一次传输时使用这个退避后的RTO。对一个没有重传的报文段而言，除非收到了一个确认，否则不要新的RTO。
```

## 4、往返时间RTT的例子

```
在本章中，我们将使用以下这些例子来检查TCP的超时和重传、慢启动以及拥塞避免等方方面面的实现细节。
```

### 1、往返时间RTT的测量

```
在图21-2左边的时间轴上有三个括号，它们表明为进行RTT计算对那些报文段进行了计时，并不是所有的报文段都被计时。

大都数源于伯克利的TCP实现在任何时候对只能存在一个测量RTT值的定时器。
在发送一个报文段时，如果给定连接的定时器已经被使用，则该报文段不被计时。
```

![](images21/01-03.jpg)

​							21-2图

```
在每次调用500ms的TCP的定时器程序时，就增加一个计数器来完成计时。这意味着，如果一个报文段的确认在它发送550ms后到达，则该报文段的往返时间RTT将是1个滴答（即500 ms）或是2个滴答(即1000 ms)。

对每个链接而言，除了这个滴答计数器，报文段中数据的起始序号也被记录下来。当收到一个包含这个序号的确认后，该定时器就被关闭。如果ACK到达时数据没有被重传，则被平滑的RTT和被平滑的均值偏差将基于这个新测量进行更新。

上图连接上的定时器在发送报文段1时启动，并在确认(报文段2)到达时终止。尽管它的RTT是1.061秒 (tcpdump的输出)，但插口排错的信息显示该过程经历了3个TCP时钟滴答，即RTT为1500ms.

下一个被计时的是报文段3.当2.4ms后传输报文段4时，由于连接的定时器已经被启动，因此该报文段不能被计时。当报文段5到达时，确认了正在被计时的数据。虽然我们从tcpdump的输出结果可以看到其RTT是0.808秒，但它的RTT被计算为1个滴答(500ms).

定时器在发送报文段6时再次被启动，并在1.015秒后接收到它的确认(报文段10)时终止。测量到的RTT是2个滴答。报文段7和9不能被计时，因为定时器已经被使用。而且，当收到报文段8(第769字节的确认)时，由于该报文段不是正在计时的数据的确认，因此什么也没有进行更新。
```

下图显示了本例中通过tcpdump的输出所得到的实际RTT与时钟滴答计数之间的关系。 

![](images21/01-04.jpg)



```
在图的上端表示间隔为500 ms的时钟滴答，图的下端表示tcpdump的输出时间及定时器何时被启动和关闭。在发送报文段1和接收到报文段2之间经历了3个滴答，时间为1.061秒，因此假定第1个滴答发生在0.03秒处（第1个滴答一定在0~0.061秒之间）。接着该图表示了第2个被测量的RTT为什么被记为1个滴答，而第3个被记为2个滴答。
```

```
在这个完整的例子中，128个报文段被传送，并收集了18个RTT采样。下图表示了测量的RTT(取自tcpdump的输出)和TCP为超时所使用的RTO(取字插口拍错的输出)。x轴从时间0开始，表示的是传输报文段1的时刻，而不是传输第一个SYN的时刻。
```

![](images21/01-05.jpg)

```
测量出RTT的前3个数据点对应21-2图的3个RTT。在时间10,14和21处的间隔是由在这些时刻附近发生的重传引起的。karn算法在另一个报文段被发送和确认之前阻止我们更新估计器。同样注意到在这个实现中，TCP计算的RTO总是500 ms的倍数。
```

### 2、RTT估计器的计算

```
让我们来看一下RTT估计器(平滑的RTT和平滑的均值偏差)是如何被初始化和更新，以及每个重传超时是怎样计算的。
	变量A和D分别被初始化为0和3秒。初始的重传超时使用下面的公式进行计算
	
	RTO = A + 2D = 0 + 2*3 = 6s
(因子2D只在这个初始化计算中使用，正如前面提到的，以后使用4D和A相加计算RTO)。这就是传输初始SYN所使用的RTO.

结果是这个初始SYN丢失了，然后超时并引起了重传。下图给出了tcpdump输出文件中的前4行。
```

![](images21/01-06.jpg)

```
当超时在5.802秒后发生时，计算当前的RTO值为
RTO = A + 4D = 0 + 4*3 = 12s

因此，应用于RTO的指数退避取为12。由于这是第1次超时，我们使用倍数2，因此下一个超时时间取值为24秒。再下一个超时时间的倍数为4，得出值为48秒（这些初始RTO，对于一个连接上的最初的SYN，取值为6秒，接下来为24秒）。

ACK在重传后467ms到达。A和D的值没有被更新，这是因为Karn算法对重传的处理比较模糊。下一个发送的报文段是第4行的ACK，但它只是一个ACK，所以没有被计时（只有数据报文段才会被计时）。

当第1个数据报文段的ACK(21-2中的报文段2)到达时，经历了3个时钟滴答，估计器被初始化为
RTTs = RTTm; 
RTTD = RTTs/2; ： 1.061ms 经历了 3个时钟滴答.
RTTm = 1.5；
RTTs = 1.5;
RTTD = 1.5/2 = 0.75;
RTO = RTTs+4*RTTD = 1.5+4*0.75 = 4.5;

当第2个数据报文段的ACK(图21-2中的报文段5)到达时，经历了1个时钟滴答(0.5秒)，估计器按如下更新：
	RTTs = (1-0.125)RTTs + 0.125*RTTm;
	RTTD = (1-0.25)RTTD + 0.25*|RTTs - RTTm|;
	RTO = RTTs + 4*RTTD;
	RTO = 4.75;
	
	    double RTTm = 1.5;
        double RTTs = 1.5;
        double RTTD = 1.5/2;
        double RTO = 0;
        RTTm = 0.5;
        RTTs = (1-0.125)*RTTs + 0.125*RTTm;
        RTTD = (1-0.25) * RTTD + 0.25 * Math.abs(RTTs - RTTm);
        RTO = RTTs + 4*RTTD;
        System.out.println(RTO);
     
RTO取值如果为 4.55秒;那么就会为 4.5秒。因为RTO必须为 500ms的倍数.
因为其超时重传的定时器为 500ms 一滴答.
```

### 3、慢启动

```
连接上最初只允许传输一个报文段，然后在发送下一个报文段之前必须等待接收它的确认。当报文段2被接收后，就可以再发送两个报文段。

我们在第20.6节介绍了慢启动算法，在图21-2中可再次看到它的工作过程。
```

## 5、拥塞举例

```
现在观察一下数据报文段的传输过程。下图显示了报文段中数据的起始序号与该报文段发送时间的对比图。它提供了一种较好的数据传输的可视化方法。通常代表数据的点将向上和向右移动，这些点的斜率就表示传输速率。当这些点向下和向右移动则表示发生了重传。

在21.4节开始时，我们曾提到整个传输的时间约为45秒，但在本图中只显示了35秒钟。这35秒只是数据报文段发送的时间。因为第1个SYN看来是丢失了并被重传（见图21-5），因此第1个数据报文段是在第1个SYN发送6.3秒后才发送的。而且，在发送最后一个数据报文段和FIN（图21-6中的34.1秒）之后，在接收方的FIN到达之前，又花费了另外的4.0秒接收来自接收方的最后14个ACK。
```

![](images21/01-07.jpg)

​								图21-6

```
可以立即看到图21-6发生在时刻10,14和21附近的3个重传。我们还可以看到在3个点中只进行了一次报文段的重传，因为只有一个点下垂低于向上的斜率。

仔细检查一下这几个下垂点中的第1个点(在10秒标记处的附近)。整理tcpdump的输出结果可以得到图21-7.

在这个图中，除了下面将要讨论的报文段72，已经去掉了其他所有的窗口通告。主机slip总是通告窗口大小为4096，而主机vangogh则通告窗口为8192。该图中报文段的编号可以看作是图21-2的延续，在那里报文段的编号从1开始。与图21-2一样，报文段根据在slip上发送和接收的顺序进行编号，tcpdump在主机slip上运行。我们还去掉了一些与讨论无关的段（第44,47和49以及所有来自vangogh的ACK）。
```

![](images21/01-08.jpg)

​							图21-7

```
看来报文段466丢失或损坏了，这一点无法从该输出上进行辨认。能够在主机 slip 上看到的是对第6657字节(报文段58)以前数据的确认。
丢失和损坏都不发送 ICMP差错报文;而是直接丢弃

紧接着的是带有相同序号的8个ACK。正是接收到报文段62，也就是第3个重复ACK，才引起自序号6657开始的数据报文段(报文段63)进行重传。的确，源于伯克利的TCP实现对收到的重复ACK进行计数，当收到第三个时，就假定一个报文段已经丢失并重传自那个序号起的一个报文段。这就是jacobson的快速重传算法，该算法通常与他的快速恢复算法一起配合使用。

快速重传算法：当收到重复的三个ACK的时候，就假定这个报文段已经丢失。将会进行重传
```

```
注意到在重传后(报文段63)，发送方继续正常的数据传输(报文段67、69和71)。TCP不需要等待对方确认重传。

现在检查一下在接收端发生了什么。当按序收到的正常数据(报文段43)后，接收TCP将255个字节的数据交给用户进程。但下一个收到的报文段(报文段46)是失序的：数据的开始序号6913并不是下一个期望的序号6657.TCP保存256字节的数据，并返回一个已成功接收数据的最大序号加1(6657)的ACK。被 vangogh 接收到的后面7个报文段（48,50,52,54,55,57和59）也是失序的，接收方TCP保存这些数据并产生重复ACK。
```

```
目前TCP尚无办法告诉对方缺少一个报文段，也无法确认失序数据。此时主机 vangogh 所能够做的就是继续发送确认序号为6657的 ACK.

当缺少的报文段(报文段 63)到达时，接收方TCP在其缓存中保存第6657~8960字节的数据，并将这2304字节的数据交给用户进程。所有这些数据在报文段。所有这些数据在报文段72中进行确认。请注意此时该ACK通告窗口大小为5888（8192-2304），这是因为确认序号是将剩余的通告窗口大小发送给对端。因为现在里面有 2304 字节，等待应用程序读取。所有8192-2304 里面有5888 win:5888;

如果仔细检查图21-6中tcpdump的输出中第14和21秒附近的下垂点，我们会看到它们也是由于收到了3个重复ACK引起的，这表明一个分组已经丢失。在这些例子中只有一个分组被重传。
```

## 6、拥塞避免算法

### 1、引言

```
计算机网络中的带宽、交换节点中的缓存和处理机等，都是网络的资源，在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况叫做拥塞。
```

### 2、慢开始与拥塞避免

```
发送方维持一个叫做拥塞窗口cwnd(congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接收方的接受能力，发送窗口可能小于拥塞窗口。

慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。

这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。
```

![](images21/01-09.jpg)

```
当然收到N个确认就增加相应的数值，所以一次传输轮次之后拥塞窗口就加倍。这就是乘法增长，和后面的拥塞避免算法的加法增长比较。
```

```
为了防止 cwnd 增长过大引起网络拥塞，还需设置一个慢开始门限 ssthresh 状态变量。ssthresh 的用法如下：
当 cwnd < ssthresh时，使用慢开始算法。(就是乘法增长)
当 cwnd > ssthresh时，改用拥塞避免算法。(一个轮次只加一个)
当 cwnd = ssthresh时，慢开始与拥塞避免算法任意。

拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。

没有收到ack就进行缩减 ssthresh(慢启动阈值)为当前拥塞窗口的一半最小为两个mss,
然后把慢启动的拥塞窗口为1，继续从1开始增长。
开始收到一个ack就为拥塞窗口增加1(虽然好像是增加1个报文段的发送量，但是其实是增加字节，拥塞窗口存储的其实也是字节)
然后直到 cwnd > ssthresh 就开始加法增长。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理)，就把慢慢始门限设置为出现拥塞时的发送窗口的一半，(最小为两个mss大小),然后把拥塞窗口设置为1，执行慢开始算法。如下图：
```

![](images21/01-10.jpg)

```
再次提醒这里只是为了讨论方便而将拥塞窗口大小的单位改为数据报的个数，实际上应当是字节。
```

### 3、快重传和恢复

```
快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。如下图：

```

![](images21/01-11.jpg)

```
快重传配合使用的还有快恢复算法，有以下两个要点：
	1、当发送方连续收到三个重复确认时，就执行"乘法减少"算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。只是将 ssthresh/2，不进行将拥塞窗口设置为1；
	2、考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为网络可能没有出现拥塞。所以此时不执行满开始算法，而是将 cwnd 设置为 ssthresh 的大小，然后执行拥塞避免算法。如下图：
```

![](images21/01-12.jpg)

### 4、随机早期检测RED

```
以上的拥塞避免算法并没有和网络层联系起来，实际上网络层的策略对拥塞避免算法影响最大的就是路由器的丢弃策略。在简单的情况下路由器通常按照先进先出的策略处理到来的分组。当路由器的缓存装不下分组的时候就丢弃到来的分组，这叫做尾部丢弃策略。这样就会导致分组丢失，发送方认为网络产生拥塞。

更为严重的是网络中存在很多TCP连接，这些连接中的报文段通常是复用路由路径。若发生路由器的尾部丢弃，可能影响到很多条TCP连接，结果就是这许多的TCP连接在同一时间进入慢开始状态。这在术语中称为全局同步。
全局同步会使得网络的通行量突然下降很多，而在网络恢复正常之后，其通信量又突然增大很多。
```

```
为避免发生网络中的全局同步现象，路由器采用随机早期检测(RED:random early detection)该算法要点如下：
	使路由器的队列维持两个参数，即队列队长 最小门限min 和 最大门限max，每当一个分组到达的时候，RED就计算平均队列长度。然后分情况对待到来的分组：
	1、平均队列长度小于最小门限 -- 把新到达的分组放入队列排队。
	2、平均队列长度在最小门限与最大门限之前 -- 则按照某一概率将分组丢弃。
	3、平均队列长度大于最大门限 -- 丢弃新 到达的分组。
```

![](images21/01-13.jpg)

```
以概率p随机丢弃分组，让拥塞控制只在个别的TCP连接上执行，因而避免全局性的拥塞控制。

RED的关键就是选择三个参数最小门限、最大门限、丢弃概念和计算平均队列长度。平均队列长度采用加权平均的方法计算平均队列长度，这和往返时间(RTT)的计算策略是一样的。
```

![](images21/01-14.jpg)

![](images21/01-15.jpg)







```
在第20.6节介绍的慢启动算法是在一个连接上发起数据流的方法，但有时我们会达到中间路由器的极限，此时分组将会被丢弃。拥塞避免算法是一种处理丢失分组方法。

该算法假定由于分组收到损坏引起的丢失是非常少的(远小于1%)，因此分组丢失就意味着在源主机和目的主机之间的某处网络上发生了拥塞。有两种分组丢失的指示：发生超时和接收到重复的确认(我们在21.5节看到这种现象。如果使用超时作为拥塞指示，则需要使用一个好的RTT算法)

拥塞避免算法和慢启动算法是两个目的不同、独立的算法。但是当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来做到这一点。在实际中这两个算法通常在一起实现。
```

```
拥塞避免算法和慢启动算法需要对每个链接维持两个变量：一个拥塞窗口cwnd 和 一个慢启动门限 ssthresh.这样得到的算法的工作过程如下：
1、对一个给定的连接，初始化cwnd为一个报文段，ssthresh为65535个字节。

2、TCP输出例程的输出不能超过cwnd和接收方通告窗口的大小。拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估计，而后者则与接收方在该连接上的可用缓存大小有关。

3、当拥塞发生时(超时或收到重复确认)，ssthresh(慢启动阈值)被设置为当前慢启动窗口大小的一半(cwnd通告窗口的一半，但是最少为2个报文段大小)。此外，如果是超时引起了拥塞，则cwnd被设置为1个报文段(这就是慢启动)。

4、当新的数据被对方确认时，就增加cwnd，但增加的方法依赖于我们是否正在进行慢启动或拥塞避免。如果cwnd小于或者等于ssthresh，则正在进行慢启动，否则正在进行拥塞避免。慢启动一直持续到我们回到当拥塞发生时所处位置的一半的时候在停止(就是 ssthresh(慢启动阈值)，的地方。)，然后转为执行拥塞避免。

```

```
	慢启动算法初始设置cwnd为1个报文段，此后每收到一个确认就加1。正如20.6节描述的那样，这会使窗口按指数方式增长：发送1个报文段，然后是2个，接着是4个......。
	
	拥塞避免算法要求每次收到一个确认时将 cwnd 增加 1/cwnd.(因为 cwnd是能发送报文段的个数)
	这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。
```











