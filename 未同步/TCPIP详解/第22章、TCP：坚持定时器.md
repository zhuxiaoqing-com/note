# 第22章 TCP的坚持定时器(零窗口探测定时器)

## 1、引言

```
我们已经看到TCP通过让接收方指明希望从发送方接收的数据字节数(即窗口大小)来进行流量控制。如果窗口大小为0会发生什么情况呢？这将有效地阻止发送方传送数据，直到窗口变为非0为止。
```

```
出现以下情况时，TCP接收方的接收缓冲区讲被塞满数据：
发送方的发送速度大于接收方的接收速度
接收方的应用程序未能及时从接收缓冲区中读取数据
```

```
当接收方的接收缓冲区满了以后，会把响应报文中的通告窗口字段置为0，从而阻止发送方的继续发送，这就是TCP的流控制。当接收方的应用程序读取了接收缓冲区中的数据以后，接收方会发送一个ACK，通过通告窗口字段告诉发送方自己又可以接收数据了，发送方收到这个ACK之后，就知道自己可以继续发送数据了。

ack会有延时发送的 默认200ms.所以win也就是接收窗口在200Ms以内被取走了部分数据的话就会空闲出一部分。
```

```
Q：那么问题来了，当接收方的接收窗口重新打开之后，如果它发送的ACK丢失了，发送方还能得知这一消息吗？
A：答案是不能。正常的ACK报文不需要确认，因而也不会被重传，如果这个ACK丢失了发送方将无法得知对端的接收窗口已经打开了，也就不会继续发送数据。这样以来，会造成死锁，接收方等待对端发送数据包，而发送方等待对端的ACK,直到连接超时关闭.
```

```
为了避免上述情况的发生，发送方实现了一个零窗口探测定时器，也叫持续定时器：
	当接收方的接收窗口为0时，每隔一段时间，发送方会主动发送探测包，通过迫使对端响应来得知其接收窗口有无打开。
	这就是山不过来，我就过去
```

## 1、激活

发送数据包时

```
在发送数据包时，如果发送失败，会检查是否需要启动零窗口探测定时器。

当网络中没有发送且未确认的数据包，且本端有待发送的数据包时，启动零窗口探测定时器。
为什么要有这两个限定条件呢？
如果网络中有发送且未确认的数据包，那这些包本身就可以作为探测包，对端的ACK即将到来。
如果没有待发送的数据包，那对端的接收窗口为不为0根本不需要考虑。

win为0时
网络中没有已经发送还未被确认的包
发送方还有待发送的数据的时候

会启动零窗口探测器
```

接收到ACK时

```
接收到ack时，会检查是否要删除或重置零窗口探测定时器。

 如果ACK打开了接收窗口，则删除零窗口探测定时器。否则根据退避指数，给予重置
 
 接收到一个ack的时候，如果之前网络中没有发送且未确认的数据段，本端又有待发送的数据段，说明可能遇到对端接收窗口为0的情况。
 这个时候会根据此ack是否打开了接收窗口来进行零窗口探测定时器的处理。
 1、如果此ack打开接收窗口。此时对端的接收窗口不为0了，可以继续发送数据包。
 那么清除超时时间的退避指针，删除零窗口探测定时器。
 2、如果此ACK是接收方对零窗口探测报文的响应，且它的接收窗口依然为0。
 那么根据指数退避算法重新设置零窗口探测定时器的下次超时时间，超时时间的设置和超时重传定时器的一样。零窗口探测定时器也使用退避指针来计算超时时间。
 
 会发送一个序号为snd_una - 1、长度为0的ACK包，对端收到此包后会发送一个ACK响应。
如此一来本端就能够知道对端的接收窗口是否打开了。
```

## 3、糊涂窗口综合征

```
就是指当发送端应用进程产生数据很慢，或接收端应用进程处理接收缓冲区数据很慢，或二者兼而有之；就会使应用进程间传送的报文段很小，特别是有效载荷很小； 极端情况下，有效载荷可能只有1个字节；传输开销有40字节(20字节的IP头+20字节的TCP头) 这种现象。
```































