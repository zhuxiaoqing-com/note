# 第20章TCP的成块数据流

## 1、引言

```
在第15章我们看到TFTP使用了停止等待协议。数据发送方在发送下一个数据块之前需要等待接收对已发送数据的确认。本章我们将介绍TCP所使用的被称为滑动窗口协议的另一种形式的流量控制方法。该协议允许发送方在停止并等待确认前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。
```

## 2、正常数据流

![](images20/01-05.jpg)

20-3

![](images20/01-01.jpg)

20-01

### 1、快的发送方和慢的接收方

```
当接受方的可用窗口为0时候，发送方将会停止发送，直到接收方再发送一个ack来更新win 窗口。这被称为窗口更新。
```

## 3、滑动窗口(通告窗口)

![](images20/01-02.jpg)

```
在这个图中，我们将字节从1至11进行标号。接收方通告的窗口称为提出的窗口(offered window),它覆盖了从第4字节到第9字节的区域，表明接收方已经确认了包括第3字节在内的数据，且通告窗口大小为6.
```

```
当接收方确认数据后，这个滑动窗口不时地向右移动。窗口两个边沿的相对运动增加或减少了窗口的大小。我们使用三个术语来描述窗口左右边沿的运动:
1、称窗口左边沿向右边靠近为窗口合拢。这种现象发生在另一端的接收进程读取已经被确认时。

2、当窗口右边沿向右移动时将允许发送更多的数据，我们称之为窗口张开。这种现象发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时。

3、当右边沿向左移动时，我们称之为窗口收缩。Host Requirements RFC强烈建议不要使用这种方式。但TCP必须能够在某一端产生这种情况时进行处理。第22.3节给出了这样的一个例子，一端希望向左移动右边沿来收缩窗口，但没能够这样做。

图20-5表示了这三种情况。因为窗口的左边沿受另一端发送的确认序号的控制，因此不可能向左边移动。如果接收到一个指示窗口左边沿向左移动的ACK，则它认为是一个重复ACK，图20-5窗口边沿的移动并被丢弃。
```

![](images20/01-03.jpg)

```
如果左边沿到达右边沿，则称其为一个零窗口，此时发送方不能发送任何数据。

合拢：窗口数据被确认时候会合拢
张开：接收方窗口win变大时候会张开
收缩:win突然变小了？然后就收缩了吧
```

### 一个例子

![](images20/01-04.jpg)

```
以该图为例可以总结如下几点：
1、发送方不必发送一个全窗口大小的数据。
2、来自接受方的一个报文段确认数据并把窗口向右边滑动。这是因为窗口的大小是相对于确认序号的。
3、正如从报文段7到报文段8中变化的那样，窗口的大小可以减小，但是窗口的有边沿却不能够向左移动。
4、接收方在发送一个ACK前不必等待窗口被填满。在前面我们看到许多实现每收到两个报文段就会发送一个ACK。
```

## 4、窗口大小

```的
由接收方提供的窗口的大小通常可以由接收进程控制，这将影响TCP的性能。
显示了在改变发送和接收缓存大小（在单向数据流动的应用中，如文件传输，只需改变发送方的发送缓存和接收方的接收缓存大小）的情况下，位于以太网上的两个工作站之间进行文件传输时的一些结果。它表明对以太网而言，默认的4096字节并不是最理想的大小，将两个缓存增加到16384个字节可以增加约40%左右的吞吐量。
```

## 5、PUSH标志

```
在每一个TCP例子中，我们都看到了PUSH标志，但一直没有介绍它的用途。发送方使用该标志通知接收方将所收到的数据全部提交给接收进程。这里的数据包括与PUSH一起传送的数据以及接收方TCP已经为接收进程收到的其他数据。

在最初的TCP规范中，一般假定编程接口允许发送进程告诉它的TCP何时设置PUSH标志。例如，在一个交互程序中，当客户发送一个命令给服务器时，它设置PUSH标志并停下来等待服务器的响应。通过允许客户应用程序通知其TCP设置PUSH标志，客户进程通知TCP在向服务器发送一个报文段时不用因等待额外数据而使已提交数据在缓存中滞留。类似地，当服务器的TCP接收到一个设置了PUSH标志的报文段时，它需要立即将这些数据递交给服务器进程而不能等待判断是否还会有额外的数据到达。

然而，目前大多数的API没有向应用程序提供通知其TCP设置PUSH标志的方法。的确，许多实现程序认为PUSH标志已经过时，一个好的TCP实现能够自行决定何时设置这个标志。

如果待发送数据将清空发送缓存，则大多数的源于伯克利的实现能够自动设置PUSH标志。这意味着我们能够观察到每个应用程序写的数据均被设置了PUSH标志，因为数据在写的时候就立即被发送。

由于源于伯克利的实现一般从不将接收到的数据推迟交付给应用程序，因此它们忽略所接收的PUSH标志。

如果待发送数据将清空发送缓存，就会标记push。
```



![](images20/01-05.jpg)

20-3

![](images20/01-01.jpg)

20-01

![](images20/01-06.jpg)

20-07

```
在图20-1中我们观察到所有8个数据报文段（4~6、9、11~13和15）的PUSH标志均被置1，这是因为客户进行了8次1024字节数据的写操作，并且每次写操作均清空了发送缓存。

再次观察图20-7，我们预计报文段12中的PUSH标志被置1，因为它是最后一个报文段。为什么发送方知道有更多的数据需要发送还设置报文段7中的PUSH标志呢？这是因为虽然我们指定写的是8192个字节的数据，但发送方的发送缓存却是4096个字节。

作为push标志的另一个例子，再次回到20-3。我们之所以看到前4个报文段(4~7)的标志被设置，是因为它们每一个均使TCP产生了一个报文段并提交给IP层。但是随后，TCP停下来等待一个确认来移动4096字节的窗口。在此期间，TCP又得到了应用程序的最后4096个字节，当窗口张开时(报文段9)，发送方TCP知道它有4个可立即发送的报文段，因此它只设置了最后一个报文段(13)的PUSH标志。
为什么还是分4次发送呢 应该 接收方和发送方的最小的mss为1024;
```

## 6、慢启动

```
迄今为止，在本章所有的例子中，发送方一开始便向网络发送多个报文段，直至达到接收方通告窗口大小为止。当发送方和接收方处于同一个局域网时，这种方式是可以的。但是如果在发送方和接收方之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题。一些中间路由器必须缓存分组，并有可能耗尽存储器的空间。耗尽了后面的数据就会被丢弃。

现在，TCP需要支持一种称为"慢启动(slow start)"的算法。该算法通过观察到新分组进入网络的速率应该与另一端返回确认速度相同而进行工作。
```

```
慢启动为发送方的TCP增加了另一个窗口：拥塞窗口(congestion window)，记为 cwnd。当与另一个网络主机建立TCP连接时，拥塞窗口被初始化为1个报文段(即另一端通告的报文段大小)。每收到一个ACK，拥塞窗口就增加一个报文段(cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加)。发送方取拥塞窗口与通告窗口中的最小值为发送上限。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。

拥塞窗口是发送方使用的流量控制
通告窗口(滑动窗口)是接收方的流量控制。
```

```
发送方开始时发送一个报文段，然后等待ACK。当收到该ACK时，拥塞窗口从1增加到2，即可以发送两个报文段。当收到这两个报文段的ACK时，拥塞窗口就增加为4.这是一种指数增加的关系。

在某些点上可能达到了互联网的容量，于是中间路由器开始丢弃分组。这就通知发送它的拥塞窗口开的过大。当我们在下一章讨论TCP的超时和重传机制时，将会看到它们是怎样对拥塞窗口起作用的。现在，我们来观察一个实际中的慢启动。
```

### 一个例子

![](images20/01-07.jpg)

```
上图表示的是将从主机sun送到主机vangogh.cs.berkeley.edu的数据。这些数据将通过一个慢的SLIP链路，该链路是TCP连接上的瓶颈（我们已经在时间系列上去掉了连接建立的过程）。

我们观察到发送方发送一个长度为512字节的报文段，然后等待ACK。该ACK在716ms后收到。这个时间是一个往返时间的指示。于是拥塞窗口增加了2个报文段，且又发送了两个报文段。当收到报文段5的ACK后，拥塞窗口增加为3。此时尽管可发送多达3个报文段，可是在下一个ACK收到之前，只发送了2个报文段。
“拥塞避免”的技术来作为通常的实现。
在21.6节中我们将再次讨论慢启动，并介绍怎样采用另一种称为“拥塞避免”的技术来作为通常的实现。
```

## 7、成块数据的吞吐量

























