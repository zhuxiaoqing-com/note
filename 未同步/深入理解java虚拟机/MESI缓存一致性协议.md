# MESI 协议中的状态

```
Cpu中每一个缓存行(cache line)使用4种状态进行标记(使用额外的两位(bit)表示)
```

## M:被修改(Modified)

```
该缓存行只被缓存在该  CPU 的缓存中，并且是被修改过的(dirty),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点(允许其他 CPU 读取主存中相应内存之前)写回(write back)主存，当被写回主存之后，该缓存行的状态会变成(exclusive)状态
```

## E：独享的 (Exclusive)

```
该缓存行只被缓存在一个 CPU 的缓存中，它是未被修改过的（clean)，与主存中数据一致。该状态可以在任何时刻当有其它CPU读取该内存时变成共享状态（shared)。同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态。
```

## **S: 共享的（Shared)** 

```
该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致（clean)，当有一个CPU修改该缓存行中，其它CPU中该缓存行可以被作废（变成无效状态（Invalid））。
```

## **I: 无效的（Invalid）**

```
该缓存是无效的（可能有其它CPU修改了该缓存行）。
```

![](mesi/01-01.png)



```
操作：
在一个典型系统中，可能会有几个缓存(在多核系统中，每个核心都会有自己的缓存)共享主存总线，每个相应的 CPU 会发出读写请求，而缓存的目的是为了减少 CPU 读写共享主存的次数
```

```
一个缓存除在Invalid状态外都可以满足cpu的读请求，一个invalid的缓存行必须从主存中读取（变成S或者 E状态）来满足该CPU的读请求。
```

```
一个写请求只有在该缓存行是M或者E状态时才能被执行，如果缓存行处于S状态，必须先将其它缓存中该缓存行变成Invalid状态（也既是不允许不同CPU同时修改同一缓存行，即使修改该缓存行中不同位置的数据也不允许）。该操作经常作用广播的方式来完成，例如：Request For Ownership (RFO)
```

```
缓存可以随时将一个非M状态的缓存行作废，或者变成Invalid状态，而一个M状态的缓存行必须先被写回主存。
```

```
一个处于M状态的缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S状态之前被延迟执行。
```

```
一个处于S状态的缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。
```

```
一个处于E状态的缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S状态。
```

```
对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的。而S状态可能是非一致的，如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。

从上面的意义看来E状态是一种投机性的优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务。
```



```
你好，有个缓存一致性的问题想向您请教一下。比如这样一个场景：有一个变量a=0；有两个线程同时在多核环境下去执行a++去更改这个变量。 按照缓存一致性是不是应该是这样一个过程：两个cpu都把a读到缓存，此时a是一个S的状态，现在两个cpu都要去修改a，但是只能有一个cpu（假设是cpu1）把a修改为M状态，另一个会变为I（失效状态），当cpu2再要去执行a++的时候，会去主存读取a(因为缓存中的a已经是失效状态)，这就会先触发cpu1缓存中的M状态的a（此时a=1）写回主存，然后cpu2才会读取到主存中a=1到缓存，这时两个cpu缓存中的a都变成S状态，然后cpu2再去做修改。---------过程如果是这样的话，最后输出的a一定是2了（测试结果并不是-。-）。我理解的这个过程什么地方有问题啊？


同时+1时，都是使用a = 0，因此两边缓存中的值都是1，然后a = 1才会触发回写，逻辑已经执行完了，不会再回退执行了。

a=0;
a++； 然后 将1 赋值给 a 的时候才改为 M;触发回写，缓存失效，但是逻辑已经执行完了，不会再回退执行了。

```

```

a=0;
a++;



```

| 线程A： 读取a到缓存L1; S 状态                                | 线程B : 读取a到缓存L1; S 状态                                |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| A: 寄存器读取 a                                              | B: 寄存器读取 a                                              |
| A: 使用运算逻辑将 a++                                        | B: 使用运算逻辑将 a++                                        |
| A:保存到寄存器为 1                                           | B:保存到寄存器为 1                                           |
| A:将寄存器里面的 1 赋值给 a; 触发 MESI的只能对 e,m状态的值进行写操作。使用 RFO 广播。时自己变为 E。其他变为 I; | B:将寄存器里面的 1 赋值给 a; 触发 MESI的只能对 e,m状态的值进行写操作。发现a为 i；重新读取；触发 读取数据之前，有M的必须先等待M写完，再读取 |
| 因为B进行了读操作，所以在读操作之前。M状态必须先刷新回主存   | a =1;然后将 1 赋值给 a;                                      |
|                                                              | 刷新回主存                                                   |
|                                                              |                                                              |





```
读操作时，只要不是 Invalid 就可以读
写操作时，必须是 Modified Exclusive 才可以写。
不然会使用 RFO(广播形式) 让其他 缓存里面的值无效
S 状态不是准确的，其他缓存变为了 Invalid 并不会广播说自己废除了该缓存，所以S 并不知道自己是不是 Exclusive 的
```

通过缓存锁定保证原子性。在同一时刻我们只需保证对某个内存地址的操作是原子性即可，

缓存锁定保证了对某个内存地址的操作是原子性。





