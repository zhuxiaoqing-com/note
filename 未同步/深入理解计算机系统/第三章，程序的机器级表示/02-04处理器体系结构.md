## 字

```
字：
	贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件见传递。通常总线被设计成传送定长的字节块，也就是字(word).
```



## 1、Y86-64指令集体系结构

```
定义一个指令集体系结构(例如 Y86-64)包括定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。

通过一个简易的自己创建的 指令集体系来了解 x86-64 指令集
```

### 1、程序员可见的状态

![](images02-04/01-01.jpg)

```
如上图所示，Y86-64程序中的每条指令都会读取或修改处理器状态的某些部分。这称为程序员可见状态。(这里的程序员即可以是 使用汇编代码的人也可以是产生机器级代码的编译器)

在处理器实现中，只要我们保证机器级程序能够访问程序员可见状态，就不需要完全按照 ISA 暗示的方式来表示和组织这个处理器状态。

上图的14个寄存器
每个程序寄存器存储一个 64 位的字。寄存器 %rsp 被入栈、出栈、调用和返回指令作为栈指针。除此之外，寄存器没有固定的含义或固定值。有3个一位的条件码;ZF SF OF,
zero sign overflow ，它们保存着最近的算术或逻辑指令所造成影响的有关信息。

程序计数器(PC)存放当前正在执行的指令的地址。
```

```
程序状态的最后一个部分是状态码 stat, 它表明程序执行的总体状态。它会指示是正常运行，还是出现了某种异常。
```



### 2、Y86-64指令

```
Y86-64指令的两个内存传送指令中的内存引用的方式是简单的基址和偏移量形式。不支持变址寄存器和寄存器值的伸缩。

OPq(operator(运算符)) 指令 指的是 addq、subq 之类的指令。

特殊指令 halt(停止)：
	halt指令停止指令的执行。 x86-64 中有一个与之相当的指令 hlt.x86-64的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。对于 y86-64 来说，指令 halt 指令会导致处理器停止，并将状态码设置为 HLT.
```

![](images02-04/01-02.jpg)

```
D Dest destination  内存地址
V immediate 立即数
F 表示不用寄存器; 
rA rB 表示寄存器A 寄存器B  register


```



### 3、指令编码

```
图 4-2 还给出了指令的字节级编码。每条指令需要 1~10 个字节不等，这取决于需要哪些字段。

每条指令的第一个字节表明指令的类型。这个字节分为两个部分，每部分 4 位：
	高 4 位是代码(code)部分，低4位是功能(function)部分。
如图 4-2 所示，代码值为 0~0xB。功能值只有在一组相关指令共用一个代码(code)时才有用。
```



![](images02-04/01-03.jpg)



```
如图 4-4 所示，15个程序寄存器中每个都有一个相对应的范围在 0 到 0xE 之间的寄存器标识符(register ID). Y86-64 中的寄存器编号跟 x86-64 中的相同。程序寄存器存在 CPU 中的一个寄存器文件中，

这个寄存器文件就是一个小的、以寄存器ID 作为地址的随机访问存储器。

在指令编码中以及在我们的硬件设计中，当需要指令不应该访问任何寄存器时，就用ID值 0xF 来表示。
```

![](images02-04/01-04.jpg)



```
有的指令只有一个字节长，而有的需要操作数的指令编码就更长一些。首先，可能有附加寄存器指示符字节(register specifier byte),指定一个或两个寄存器。
在图4-2中，这些寄存器字段称为 rA- rB。 从指令的汇编代码中可以看到，根据指令类型，指令可以指定用于数据源和目的的寄存器，或是用于地址计算的基址寄存器。

没有寄存器操作数的指令，例如，分支指令和 call 指令，就没有寄存器指示符字节。

那些只需要一个寄存器操作数的指令(irmovq pushq popq)将另一个寄存器指示符 OxF 。这种约定在我们处理器实现中非常有用。
```



```
有些指令需要一个附加的 4 字节常数字(constant word).这个字能作为 irmovq 的立即数数据， rmmovq 和 mrmovq 的地址指示符的偏移量，以及分支指令和调用指令的目的地址。

注意，分支指令和调用指令的目的是一个绝对地址。

所有整数采用小端法编码。
```



### 4、Y86-64异常

```
对 Y86-64 来说，程序员可见的状态 状态码(stat)，它描述程序执行的总体状态。这个代码可能的值如图 4-5 所示。
```

![](images02-04/01-05.jpg)



```
代码值 1，命名为 AOK，表示程序执行正常，而其他一些代码则表示发生了某种类型的异常。

代码值 2，命名为 HLT，表示处理器执行了一条 halt 指令。

代码值 3，命名为 ADR，表示处理器试图从一个非法内存地址读或者向一个非法内存地址写，可能是当取指令的时候，也可能是当读或者写数据的时候。我们会限制最大的地址(确切的限定值因实现而异)，任何访问超出这个限定值的地址都会引发 ADR 异常。

代码4，命名为 INS， 表示遇到了非法的指令代码。
```



### 6、一些 Y86-64 指令的详情

```
大多数 Y86-64 指令是以一种直接明了的方式修改程序状态的，所以定义每条指令想要达到的结果并不困难。不过，两个特别的指令的组合需要特别注意一下。

pushq %rsp 和 popq %rsp
```

```
pushq d指令会把栈指针减 8， 并且将一个寄存器值写入内存中。因此，当执行 pushq %rsp 指令时，处理器的行为是不确定的，因为要入栈的寄存器会被同一条指令修改。通常有两种不同的约定： 
	1、压入 %rsp的原始值。
	2、压入减去 8 的 %rsp 的值。
	
	不同处理器的细节可能是不一样的。所以一般编译器并不会用个push 和 pop 指令
```



## 2、逻辑设计和硬件控制语言 HCL

```
 在硬件设计中，用电子电路来计算对位进行运算的函数，以及在各种存储器单元中存储位。大多数现代电路技术都是用信号线上的高电压或低电压表示不同的位值。
 
 在当前的技术中，逻辑 1 是用 1.0 伏特左右的高电压表示的，而逻辑 0 是用 0.0 伏特左右的低电压表示的。要实现一个数字系统需要三个主要的组成部分：
 计算对位进行操作的函数的组合逻辑、
 存储位的存储器单元，
 以及控制存储器单元更新的时钟信号。
 
 HCL (Hardware Control Language)硬件控制语言
```

### 1、逻辑门

```
逻辑门是数字电路的基本计算单元。它们产生的输出，等于它们输入位值的某个布尔函数。

逻辑门只对单个位的数进行操作，而不是整个字。

逻辑门可以 n 路操作， n>2;

比如 输入为 a b c;  a&&b&&cs
```

![](images02-04/01-06.jpg)



### 2、组合电路和HCL布尔表达式

```
将很多逻辑门组合成一个网，就能构建计算块(computational block),称为组合电路(combinational circuits).

如何构建这些网有几个限制：

	-每个逻辑门的输入必须连接到下述选项之一：
		1、系统输入(称为主输入)
		2、某个存储器单元的输出
		3、某个逻辑门的输出
	
	-两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障。
	
	-这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。
	
	
```

![](images02-04/01-07.jpg)



```
图 4-10 是一个我们觉得非常有用的简单 组合电路的例子。它有两个输入 a 和 b, 有唯一的输出 eq,当 a 和 b 都是 1 (从上面的  AND 门可以看出)或都是 0(从下面的 AND 门可以看出)时，输出为 1. 用 HCL 来写这个网的函数就是 ：
bool eq = (a&&b) || (!a&&!b);

这段代码简单的定义了位级(数据类型 bool 表明了这一点)信号 eq, 它是输入 a 和 b 的函数。从这个例子可以看出 HCL 使用了 C 语言风格的语法， '=' 将一个信号名与一个表达式联系起来。不过同 C 不一样，我们不把它看成执行了一次计算并将结果放入内存中某个位置。相反，它只是给表达式一个名字.
```



```
图 4-11 给出了 另一个简单但很有用的组合电路，称为 多路复用器(multiplexor，通常称为 'MUX') .多路复用器根据输入控制信号的值，从一组不同的数据信号中选一个。

在这个单个位的多路复用器中，两个数据信号是输入位 a 和 b，控制信号是输入位 s。当 s 为 1时，输出等于 a； 而当 s 为 0 时，输出等于 b。

```

### 3、字级的组合电路和 HCL 整数表达式

```
通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。
通常，我们设计能对数据字(word)进行操作的电路。
有一些位级信号，代表一个整数或一些控制模式。
```

![](images02-04/01-08.jpg)























