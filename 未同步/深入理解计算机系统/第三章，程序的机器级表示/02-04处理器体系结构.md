## 字

```
字：
	贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件见传递。通常总线被设计成传送定长的字节块，也就是字(word).
```



## 1、Y86-64指令集体系结构

```
定义一个指令集体系结构(例如 Y86-64)包括定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。

通过一个简易的自己创建的 指令集体系来了解 x86-64 指令集
```

### 1、程序员可见的状态

![](images02-04/01-01.jpg)

```
如上图所示，Y86-64程序中的每条指令都会读取或修改处理器状态的某些部分。这称为程序员可见状态。(这里的程序员即可以是 使用汇编代码的人也可以是产生机器级代码的编译器)

在处理器实现中，只要我们保证机器级程序能够访问程序员可见状态，就不需要完全按照 ISA 暗示的方式来表示和组织这个处理器状态。

上图的14个寄存器
每个程序寄存器存储一个 64 位的字。寄存器 %rsp 被入栈、出栈、调用和返回指令作为栈指针。除此之外，寄存器没有固定的含义或固定值。有3个一位的条件码;ZF SF OF,
zero sign overflow ，它们保存着最近的算术或逻辑指令所造成影响的有关信息。

程序计数器(PC)存放当前正在执行的指令的地址。
```

```
程序状态的最后一个部分是状态码 stat, 它表明程序执行的总体状态。它会指示是正常运行，还是出现了某种异常。
```



### 2、Y86-64指令

```
Y86-64指令的两个内存传送指令中的内存引用的方式是简单的基址和偏移量形式。不支持变址寄存器和寄存器值的伸缩。

OPq(operator(运算符)) 指令 指的是 addq、subq 之类的指令。

特殊指令 halt(停止)：
	halt指令停止指令的执行。 x86-64 中有一个与之相当的指令 hlt.x86-64的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。对于 y86-64 来说，指令 halt 指令会导致处理器停止，并将状态码设置为 HLT.
```

![](images02-04/01-02.jpg)

```
D Dest destination  内存地址
V immediate 立即数
F 表示不用寄存器; 
rA rB 表示寄存器A 寄存器B  register


```



### 3、指令编码

```
图 4-2 还给出了指令的字节级编码。每条指令需要 1~10 个字节不等，这取决于需要哪些字段。

每条指令的第一个字节表明指令的类型。这个字节分为两个部分，每部分 4 位：
	高 4 位是代码(code)部分，低4位是功能(function)部分。
如图 4-2 所示，代码值为 0~0xB。功能值只有在一组相关指令共用一个代码(code)时才有用。
```



![](images02-04/01-03.jpg)



```
如图 4-4 所示，15个程序寄存器中每个都有一个相对应的范围在 0 到 0xE 之间的寄存器标识符(register ID). Y86-64 中的寄存器编号跟 x86-64 中的相同。程序寄存器存在 CPU 中的一个寄存器文件中，

这个寄存器文件就是一个小的、以寄存器ID 作为地址的随机访问存储器。

在指令编码中以及在我们的硬件设计中，当需要指令不应该访问任何寄存器时，就用ID值 0xF 来表示。
```

![](images02-04/01-04.jpg)



```
有的指令只有一个字节长，而有的需要操作数的指令编码就更长一些。首先，可能有附加寄存器指示符字节(register specifier byte),指定一个或两个寄存器。
在图4-2中，这些寄存器字段称为 rA- rB。 从指令的汇编代码中可以看到，根据指令类型，指令可以指定用于数据源和目的的寄存器，或是用于地址计算的基址寄存器。

没有寄存器操作数的指令，例如，分支指令和 call 指令，就没有寄存器指示符字节。

那些只需要一个寄存器操作数的指令(irmovq pushq popq)将另一个寄存器指示符 OxF 。这种约定在我们处理器实现中非常有用。
```



```
有些指令需要一个附加的 4 字节常数字(constant word).这个字能作为 irmovq 的立即数数据， rmmovq 和 mrmovq 的地址指示符的偏移量，以及分支指令和调用指令的目的地址。

注意，分支指令和调用指令的目的是一个绝对地址。

所有整数采用小端法编码。
```



### 4、Y86-64异常

```
对 Y86-64 来说，程序员可见的状态 状态码(stat)，它描述程序执行的总体状态。这个代码可能的值如图 4-5 所示。
```

![](images02-04/01-05.jpg)



```
代码值 1，命名为 AOK，表示程序执行正常，而其他一些代码则表示发生了某种类型的异常。

代码值 2，命名为 HLT，表示处理器执行了一条 halt 指令。

代码值 3，命名为 ADR，表示处理器试图从一个非法内存地址读或者向一个非法内存地址写，可能是当取指令的时候，也可能是当读或者写数据的时候。我们会限制最大的地址(确切的限定值因实现而异)，任何访问超出这个限定值的地址都会引发 ADR 异常。

代码4，命名为 INS， 表示遇到了非法的指令代码。
```



### 6、一些 Y86-64 指令的详情

```
大多数 Y86-64 指令是以一种直接明了的方式修改程序状态的，所以定义每条指令想要达到的结果并不困难。不过，两个特别的指令的组合需要特别注意一下。

pushq %rsp 和 popq %rsp
```

```
pushq d指令会把栈指针减 8， 并且将一个寄存器值写入内存中。因此，当执行 pushq %rsp 指令时，处理器的行为是不确定的，因为要入栈的寄存器会被同一条指令修改。通常有两种不同的约定： 
	1、压入 %rsp的原始值。
	2、压入减去 8 的 %rsp 的值。
	
	不同处理器的细节可能是不一样的。所以一般编译器并不会用个push 和 pop 指令
```



## 2、逻辑设计和硬件控制语言 HCL

```
 在硬件设计中，用电子电路来计算对位进行运算的函数，以及在各种存储器单元中存储位。大多数现代电路技术都是用信号线上的高电压或低电压表示不同的位值。
 
 在当前的技术中，逻辑 1 是用 1.0 伏特左右的高电压表示的，而逻辑 0 是用 0.0 伏特左右的低电压表示的。要实现一个数字系统需要三个主要的组成部分：
 计算对位进行操作的函数的组合逻辑、
 存储位的存储器单元，
 以及控制存储器单元更新的时钟信号。
 
 HCL (Hardware Control Language)硬件控制语言
```

### 1、逻辑门

```
逻辑门是数字电路的基本计算单元。它们产生的输出，等于它们输入位值的某个布尔函数。

逻辑门只对单个位的数进行操作，而不是整个字。

逻辑门可以 n 路操作， n>2;

比如 输入为 a b c;  a&&b&&cs
```

![](images02-04/01-06.jpg)



### 2、组合电路和HCL布尔表达式

```
将很多逻辑门组合成一个网，就能构建计算块(computational block),称为组合电路(combinational circuits).

如何构建这些网有几个限制：

	-每个逻辑门的输入必须连接到下述选项之一：
		1、系统输入(称为主输入)
		2、某个存储器单元的输出
		3、某个逻辑门的输出
	
	-两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障。
	
	-这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。
	
	
```

![](images02-04/01-07.jpg)



```
图 4-10 是一个我们觉得非常有用的简单 组合电路的例子。它有两个输入 a 和 b, 有唯一的输出 eq,当 a 和 b 都是 1 (从上面的  AND 门可以看出)或都是 0(从下面的 AND 门可以看出)时，输出为 1. 用 HCL 来写这个网的函数就是 ：
bool eq = (a&&b) || (!a&&!b);

这段代码简单的定义了位级(数据类型 bool 表明了这一点)信号 eq, 它是输入 a 和 b 的函数。从这个例子可以看出 HCL 使用了 C 语言风格的语法， '=' 将一个信号名与一个表达式联系起来。不过同 C 不一样，我们不把它看成执行了一次计算并将结果放入内存中某个位置。相反，它只是给表达式一个名字.
```



```
图 4-11 给出了 另一个简单但很有用的组合电路，称为 多路复用器(multiplexor，通常称为 'MUX') .多路复用器根据输入控制信号的值，从一组不同的数据信号中选一个。

在这个单个位的多路复用器中，两个数据信号是输入位 a 和 b，控制信号是输入位 s。当 s 为 1时，输出等于 a； 而当 s 为 0 时，输出等于 b。

```

### 3、字级的组合电路和 HCL 整数表达式

```
通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。
通常，我们设计能对数据字(word)进行操作的电路。
有一些位级信号，代表一个整数或一些控制模式。
```

![](images02-04/01-08.jpg)



```
	处理器中会用到很多种多路复用器，使得我们能根据某些控制条件，从许多源中选出一个滋. 在 HCL 中，多路复用函数式是用 情况表达式(case expression)来描述的。情况表达式的通用格式如下：
```

![](images02-04/01-09.jpg)



![](images02-04/01-10.jpg)

```
在这段代码中，第二个选择表达式就是 l,表明如果前面没有情况被选中，那就选择这种情况。这是 HCL 中一种指定默认情况的方法。几乎所有的情况表达式都是以此结尾的。

表达式互斥 指的是 A,B 两个条件。
A：{1,2，3} 这三个满足一个就可以了
B:{2,4,5} 这三个满足一个就可以了

此时如果是 2的话  A 或者 B  满足的。因为 A和B里面有交集 这种的就是不互斥的。

A:{1,2}
B:{3,4} 
这种的就是互斥的。 没有交集
```



![](images02-04/01-11.jpg)



### 4、ALU

```
组合逻辑电路可以设计成在字级数据上执行许多不同类型的操作。具体的设计已经超出了我们套路的范围。

算术/逻辑单元(ALU)是一种很重要的组合电路，图4-15 是它的一个抽象的图示。这个电路有三个输入：
标号为 A 和 B 的两个数据输入，以及一个控制输入。

根据控制输入的设置，电路会对数据输入执行不同的算术或逻辑操作。
可以看到，这个 ALU 中画的四个操作对应于 Y86-64 指令集支持的四种不同的整数操作，而控制值和这些操作相对应。我们还注意到减法的操作数顺序，是输入B减去输入A。
之所以这样做，是为了使这个顺序与 subq 指令的参数顺序一致。
```



![](images02-04/01-12.jpg)



### 5、集合关系

```
在处理器设计中，很多时候都需要将一个信号与许多可能匹配的信号作比较，以此来检测正在处理的某个指令代码是否属于某一类指令代码。
```

![](images02-04/01-13.jpg)



### 6、存储器和时钟

```
时序电路，是由最基本的逻辑门电路加上反馈逻辑回路（输出到输入）或器件组合而成的电路，与组合电路最本质的区别在于时序电路具有记忆功能。
```



```
组合电路从本质上讲，不存储任何信息。相反，它们只是简单的响应输入信号，产生等于输入的某个函数的输出。
为了产生时序电路(swquential circuit)，我们必须引入按位存储信息的设备。

存储设备都是由同一个时钟控制的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。
考虑两类存储器设备：
 - 时钟寄存器(简称寄存器)存储单个位或字。时钟信号控制寄存器加载输入值。
 
 -随机访问存储器(简称内存)存储多个字，用地址来选择该读或该写哪个字。
 随机访问存储器的例子包括：
 	1）处理器的虚拟内存系统，硬件和操作系统结合起来使处理器可以在一个很大的地址空间内访问任意的字;
 	2)寄存器文件，在此，寄存器标识符作为地址。在IA32或Y86-64处理器中，寄存器文件有 15 个寄存器(%rax~%r14).
```

```
正如我们看到的那样，在说到硬件和机器级编码时，"寄存器"这个词是两个有细微差别的事情。
在硬件中，寄存器直接将它的输入和输出线连接到电路的其他部分。

在机器级编码中，寄存器代表的是  CPU 中为数不多的可寻址的字，这里的地址时寄存器ID。这些字通常都存在寄存器文件中，虽然我们会看到硬件有时可以直接将一个字从一个指令传送到另一个指令，以避免先写寄存器文件再读出来的延迟。

需要避免歧义时，我们会分别称呼这两类寄存器为"硬件寄存器"和"程序寄存器"。
```



```
图4-16更详细地说明了一个硬件寄存器以及它是如何工作的。
大多数时候，寄存器都保持在稳定状态(用 x 表示)，产生的输出等于它的当前状态。
信号沿着寄存器前面的组合逻辑传播，这时，产生了一个新的寄存器输入(用 y 表示)，但只要时钟是低电位的，寄存器的输出就仍然保持不变。
当时钟变成高电位的时候，输入信号就加载到寄存器中，称为下一个状态 y, 直到下一个时钟上升沿，这个状态就一直是寄存器的新输出。
关键是寄存器是作为电路不同部分中的组合逻辑之间的屏障。每当每个时钟到达上升沿是时，值才会从寄存器的输入传送到输出。

我们的 Y86-64 处理器会用时钟寄存器保存程序计数器(PC)、条件代码(CC)和程序状态(Stat).
```

![](images02-04/01-14.jpg)



```
寄存器文件有两个读端口(A和B)，还有一个写端口(W).这样一个多端口随机访问存储器允许同时进行多个读和写操作。图中所示的寄存器文件中，电路可以读两个程序寄存器的值，同事更新第三个寄存器的状态。
每个端口都有一个地址输入，表明该选择哪个程序寄存器，另外还有一个数据输出或对应该程序寄存器的输入值。
地址是由图 4-4 中编码表示的寄存器标识符。两个读端口有地址输入 srcA 和 srcB("sourceA"和"sourceB" 的缩写)和数据输出 valA 和 valB(value).
写端口有地址输入dstW(destination W),以及数据输入 valW.
```

```
虽然寄存器文件不是组合电路，因为它有内部存储。不过，在我们实现中，从寄存器文件读数据就好像它是一个以地址为输入、数据为输出的一个组合逻辑块。当 srcA 或 srcB  上。例如,将 srcA 设为 3.就会读出程序寄存器 %rbx 的值，然后这个值就会出现在输出 valA 上.
```

```
向寄存器文件写入字是由时钟信号控制的,控制方式类似于将值加载到时钟寄存器.每次时钟上升时,输入 valW 上的值会被写入输入 dstW 上的寄存器ID 指示的程序寄存器。

当dstW 设为特殊的 ID 值 0xF 时，不会写任何程序寄存器。 
```

![](images02-04/01-15.jpg)

```
内存类似于寄存器文件。

这个内存有一个地址输入，一个写的数据输入，以及一个读的数据输出。同寄存器文件一样，从内存中读的操作方式类似于组合逻辑: 
	如果我们在输入 address 上 提供一个地址，并将 write 控制信号设置为 0，那么在经过一些延迟之后，存储在那个地址上的值会出现在输出 data 上。
	如果地址超出了范围，error信号会设置为1，否则就设置为 0.
	
	
写内存是由时钟控制的：
我们将 address 设置为期望的地址，将 data in  设置为期望的值，而 write 设置为 1.	然后当我们控制时钟时，只要地址时合法的，就会更新内存中指定的位置。对于读操作来说，如果地址是不合法的， error 信号会被设置为 1.这个信号是由组合逻辑产生的，因为所需要的边界检查纯粹就是地址输入的函数，不涉及任何状态。

读用 write 0. 写用 write 1

寄存器有两个读一个写。
内存有一个读一个写。
```

```
	我们的处理器还包括另外一个只读存储器，用来读指令。在大多数实际系统中，这两个存储器被合并为一个具有双端口的存储器，一个用来读指令，另一个用来读或者写数据。
```



## 3、Y86-64的顺序实现

```
现在已经有了实现 Y86-64 处理器所需要的部件。首先，我们描述一个称为 SEQ(sequential 顺序的)的处理器。每个时钟周期上，SEQ执行处理一条完整指令所需的所有步骤。不过，这需要一个很长的时钟周期时间，因此时钟周期频率会低到不可接受。我们开发 SEQ 的目标就是提供实现最终目的的第一步，我们的最终目的是实现一个高效的、流水线化的处理器。
```

### 1、将处理组织成阶段

```
通常，处理一条指令包括很多操作。将它们组织成某个特殊阶段序列，即使指令的动作差异很大，但所有的指令都遵循统一的序列。每一步的具体处理取决于正在执行的指令。创建这样一个框架，我们就能设计一个充分利用硬件的处理器。
下面是关于各个阶段以及各阶段内执行操作的简略描述：
	
	
```

#### 取指(fetch)

```
取指(fetch): 取指阶段从内存读取指令字节，地址为程序计数器(PC)的值。
从指令中抽取出指令指示符字节的两个四位部分，称为 icode(指令代码) 和 ifun(指令功能)。
它可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数指示符 rA 和 rB.
它还可能取出一个四字常数字 valC. 
它按顺序方式计算当前指令的下一条指令的地址 valP. 
也就是说，valP 等于 PC 的值加上已取出指令的长度。
```

#### 译码(decode)

```
译码阶段从寄存器文件读入最多两个操作数，得到值 valA 和 valB. 
通常，它读入指令 rA 和 rB 字段指明的寄存器，不过有些指令是读寄存器 %rsp 的。
```

#### 执行(execute)

```
在执行阶段, 算术/逻辑单元(ALU)要么执行指令指明的操作(根据 ifun 的值)，计算内存引用的有效地址，要么增加或减少栈指针。得到的值我们称为 valE.在此，也可能设置条件码。
对一条条传送指令来说，这个阶段会检验条件码和传送条件(由 ifun 给出)，如果条件成立，则更新目标寄存器。
同样，对于一条跳转指令来说，这个阶段会决定是不是应该选择分支。
```

#### 访存(memory)

```
访存阶段可以将数据写入内存，或者从内存读出数据。读出的值为 valM.
```

#### 写回(write back)

```
写回阶段最多可以写两个结果到寄存器文件。
```

#### 更新PC(pc  update)

```
将 PC 设置成下一条指令的地址。
```


```
处理器会无限循环，执行这些阶段。在我们简化的实现中，发生任何异常时，处理器就会停止：它执行halt 指令或非法指令，或它试图读或者写非法地址。
在更完整的设计中，处理器会进入异常处理模式，开始执行由异常的类型决定的特殊代码。
```

```
从前面的讲述可以看出，执行一条指令是需要进行很多处理的。
我们不仅必须执行指令所表明的操作，还必须计算地址、更新栈指针，以及确定下一条指令的地址。
幸好每条指令的整个流程都比较相似。
因为我们想使硬件数量尽可能少，并且最终将把它映射到一个二维的集成电路芯片的表面，在设计硬件时，一个非常简单而一致的结构是非常重要的。降低复杂度的一种方法是让不同的指令共享尽量多的硬件。
例如：我们的每个处理器设计都只含有一个算术/逻辑单元，根据所执行的指令类型的不同，它的使用方式也不同。在硬件上复制逻辑块的成本比软件中有重复代码的成本大得多。
```































