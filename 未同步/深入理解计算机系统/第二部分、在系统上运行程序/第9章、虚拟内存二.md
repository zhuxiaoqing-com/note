## 8、内存映射

```
需要说明一点，并不是所有物理内存中交换出来的数据都会被放到 Swap 中(如果这样的话，Swap 就会不堪重负)，有相当一部分数据被直接交换到文件系统。
例如，有的程序会打开一些文件，对文件进行读写(其实每个程序都至少要打开一个文件，那就是运行程序本身)，当需要将这些程序的内存空间交换出去时，就没有必要将文件部分的数据放到 swap 空间中了，而可以直接将其放到文件里去。
如果是读文件操作，那么内存数据被直接释放，不需要交换出来，因为下次需要时，可直接从文件系统恢复;
如果是写文件，只需要将变化的数据保存到文件中，以便恢复。
但是那些用 malloc 和 new 函数生成的对象的数据则不同，它们需要 swap 空间，因为它们在文件系统中没有相应的"储备"文件，因此被称作"匿名"(Anonymous)内存数据。
这类数据还包括堆栈中的一些状态和变量数据等。
所以说,Swap 空间是"匿名"数据的交换空间。
```



```
Linux 通过将一个虚拟内存区域与一个磁盘上的对象(object)关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。
虚拟内存区域可以映射到两种类型的对象中的一种：
```

```
1、Linux 文件系统中的普通文件：
一个区域可以映射到一个普通文件的连续部分，例如一个可执行文件。
文件区(section)被分为页大小的片，每一片包含一个虚拟页面的初始内容。
因为按需进行页面调度，所以这些虚拟页面没有实际交换进入物理内存，直到CPU第一次引用到页面(即发射一个虚拟地址，落在地址空间这个页面的范围之内)。
如果区域比文件区要大，那么就用零来填充这个区域的余下部分。
```

```
2、匿名文件：
一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。
CPU第一次引用这样一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，将这个页面标记为是驻留在内存中的。
注意在磁盘和内存之间并没有实际的数据传送。
因为这个原因，映射到匿名文件的区域中的页面有时也叫做请求二进制零的页(demand-zero page)。
```

```
无论在哪种情况中，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件(swap file)之间换来换去。
交换文件也叫做交换空间(swap space)或者交换区域(swap area)。
需要意识到很重要的一点是，在任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数。
```



### 1、再看共享对象

```
内存映射的概念来源于一个聪明的发现：如果虚拟内存系统可以集成到传统的文件系统中，那么就能提供一种简单而高效的把程序和数据加载到内存中的方法。
```

````
正如我们已经看到的，进程这一抽象能够为每个进程提供自己私有的虚拟地址空间，可以免受其他进程的错误读写。
不过，许多进程有同样的只读代码区域。
例如，每个运行 Linux shell 程序 bash 的进程有相同的代码区域。
而且，许多程序需要访问只读运行时库代码的相同副本。
例如，每个C程序都需要来自标准C库的诸如printf 这样的函数。
那么，如果每个进程都在物理内存中保持这些常用代码的副本，那就是极端的浪费了。
幸运的是，内存映射给我们提供了一种清晰的机制，用来控制多个进程如何共享对象。
````

```
一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。
如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟内存的其他进程而言，也是可见的。
而且，这些变化也会反应在磁盘上的原始对象中。
```

```
另一方面，对于一个映射到私有
```

















