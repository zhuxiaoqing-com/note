**异常控制流**

```
非本地跳转(即违反通用的调用/返回栈规则的跳转)
```

```
从给处理器加电开始，知道你断电为止，程序计数器假设一个值的序列
a(0),a(1),...,a(n-1)

其中，每个a(k)是某个相应指令I(k)的地址。
每次从a(k)到a(k+1)的过渡称为控制转移(control transfer).
这样的控制转移序列叫做处理器的控制流(flow of control 或 control flow).

最简单的一种控制流是一个"平滑的"序列，其中每个 I(k)和I(k+1)在内存中都是相邻的。这种平滑流的突变(也就是I(k+1)与I(k)不相邻)通常是由诸如跳转、调用和返回这样的一些熟悉的指令造成的。
这样一些指令都是必要的机制，使得程序能够对由程序变量表示的内部程序状态中的变化做出反应。

但是系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。
比如，一个硬件定时器定期产生信号，这个事件必须得到 处理。包到达网络适配器后，必须放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。当子进程终止时，创造这些子进程的父进程必须得到通知。

现代系统通过使控制流发生突变来对这些情况作出反应。一般而言，我们把这些突变称为异常控制流(Exceptional control flow, ECF).
异常控制流发生在计算机系统的各个层次。
比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序
在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。
在应用层，一个进程可以发送信号到另一个进程，而接收者会将控制突然转移到它的一个信号处理程序。一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。
```

```
作为程序员，理解ECF很重要，这有很多原因：
理解ECF将帮助你理解重要的系统概念。ECF是操作系统用来实现I/O、进程和虚拟内存的基本机制。在能够真正理解这些重要概念之前，你必须理解ECF。

理解ECF将帮助你理解应用 程序时如何与操作系统交互的。应用程序通过使用一个叫做陷阱(trap)或者系统调用(system call)的ECF形式，向操作系统请求服务。
比如，向磁盘写数据、从网络读取数据、创建一个新进程，以及终止当前进程，都是通过应用程序调用系统调用来实现的。理解基本的系统调用机制将帮助你理解这些服务是如何提供给应用的。

理解ECF将帮助你编写有趣的新应用程序。操作系统为应用程序提供了强大的ECF机制，用来创建新进程、等待进程终止、通知其他进程系统中的异常事件，以及检测和响应这些事件。如果理解了这些ECF机制，那么你就能用它们来编写诸如 Unix shell 和web服务器之类有趣程序了。

理解ECF将帮助你理解并发。ECF是计算机系统中实现并发的基本机制。在运行中的并发的例子有：中断应用程序执行的异常处理程序，在时间上重叠执行的进程和线程，以及中断应用程序执行的信号处理程序。理解ECF是理解并发的第一步。我们会在第12章中更详细的研究并发。

理解ECF将帮助你理解软件异常如何工作。像C++ 和 java 这样的语言通过 try、catch 以及 throw 语句来提供软件异常机制。软件异常允许程序进行非本地跳转(即违反通用的调用/返回栈规则的跳转)来响应错误情况。非本地跳转是一种应用层ECF，在 C中是通过 setjmp 和 longjmp函数提供的。理解这些低级函数将帮助你理解高级软件异常如何得以实现。
```

```
对系统的学习，到目前为止你已经了解了应用是如何与硬件交互的。本章的重要性在于你讲开始学习应用是如何与擦偶作系统交互的。
有趣的是，这些交互都是围绕着ECF的。我们将描述存在于一个计算机系统中所有层次上的各种形式的 ECF。从异常开始，异常位于硬件和操作系统交界的部分。
我们还会讨论系统调用，它们是为应用程序提供到操作系统的入口点的异常。
然后我们会提升抽象的层次，描述进程和信号，它们位于应用和操作系统的交界之处。最后讨论非本地跳转，这是ECF的一种应用层形式。
```



## 1、异常

```
异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。
因为有一个部分是由硬件实现的，所以具体细节将随系统的不同而有所不同。然而，对于每个系统而言，基本的思想都是相同的。在这一节中我们的目的是让你对异常和异常处理有一个一般性的了解，并且想你揭示现在计算机系统的一个经常令人感到迷惑的方面。
```

```
异常(exception)就是控制流中的突变，用来响应处理器状态中的某些变化。图8-1展示了基本的思想。
```

![](images08-01/01-01.jpg)

```
在图中，当处理器状态中发生一个重要的变化时，处理器正在执行某个当前指令 I(curr).
在处理器中，状态被编码为不同的位和信号。状态变化称为事件(event).事件可能和当前指令的执行直接相关。
比如，发生虚拟内存缺页、算术溢出，或者一条指令试图除以零。
另一方面，事件也可能和当前指令的执行没有关系。
比如，一个系统定时器产生信号或者一个I/O请求完成。
```

```
在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表(exception table)的跳转表，进行一个间接过程调用(异常)，到一个专门设计用来处理这类事件的操作系统子程序(异常处理程序(exception handler))。
当异常处理程序完成处理后，根据引起异常的类型，会发生以下3种情况的一种：
1、处理程序将控制返回给当前指令 I(curr),即当事件发生时正在执行的指令。
2、处理程序将控制返回给I(next),如果没有发生异常将会执行的下一条指令。
3、处理程序终止被中断的程序。
```



### 1、异常处理

```
异常可能会难以理解，因为处理异常需要硬件和软件紧密合作。很容易搞混哪个部分执行哪个任务。让我们更详细地来看看硬件和软件的分工吧。
```

```
系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号(exception number).
其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核(操作系统常驻内存的部分)的设计者分配的。
前者的示例包括被零除、缺页、内存访问违例、断点以及算术运算溢出。
后者的示例包括系统调用和来自外部I/O设备的信号。
```

```
在系统启动时(当计算机重启或加电时)，操作系统分配和初始化一张称为异常表的跳转表，使得表目k包含异常k的处理程序的地址。图8-2展示了异常表的格式。
```

![](images08-01/01-02.jpg)



```
在运行时(当系统在执行某个程序时)，处理器检测到发生了一个事件，并且确定了相应的异常号k。随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目k，转到相应的处理程序。
图8-3展示了处理器如何使用异常表来形成适当的异常处理程序的地址。
异常号是到异常表中的索引，异常表的起始地址放在一个叫做异常标记址寄存器(exception table base register)的特殊CPU寄存器里。
```

![](images08-01/01-03.jpg)

```
异常类似于过程调用，但是有一些重要的不同之处：
1、过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令(当事件发生时正在执行的指令)，要么是下一条指令(如果事件不发生，将会在当前指令后执行的指令)。

2、处理器也把一些额外的处理器状态压入到栈中，在处理器程序返回时，重新开始执行被中断的程序会需要这些状态。比如，x86-64系统会将包含当前条件码的 EFLAGS寄存器和其他内容压入栈中。

3、如果控制从用户程序转移到内核，所有这些项目都被压入到内核栈中，而不是压到用户栈中。

4、异常处理程序运行在内核模式下，这意味着它们对所有的系统资源都有完全的访问权限。

一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。在处理程序处理完事件之后，它通过执行一条特殊的"从中断返回"指令，可选的返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中，如果异常中断的是一个用户程序，九江状态恢复为用户模式，然后将控制返回给被中断的程序。
```















