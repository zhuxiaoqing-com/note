**链接**

```
链接(linking)是将各种代码和数据片段收集并组合成一个单一的文件的过程，这个文件可被加载(复制)到内存并执行。
链接可以执行于编译时(compile time),也就是在源代码被翻译成机器代码时;
也可以执行于加载时(load time),也就是在程序被加载器(loader)加载到内存并执行；
甚至可以执行于运行时(run time),也就是由应用程序来执行。

在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器(linker)的程序自动执行的。
```

```
链接器在软件开发中扮演一个关键的角色，因为它们使得分离编译(separate compilation) 成为可能。
我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。
当我们改变这些模块中的一个时，只需简单的重新编译它，并重新链接应用，而不必重新编译其他文件。
```



## 1、编译器驱动程序

![](images07-01/01-01.jpg)



![](images07-01/01-02.jpg)

```
大多数编译系统提供编译器驱动程序(compiler driver),它代表用户在需要时调用语言与处理器、编译器、汇编器和链接器。
```

```
图7-2概括了驱动程序在将示例陈旭从ASCII码源文件翻译成可执行目标文件时的行为。(如果你想看看这些步骤， 用 - v 选项来运行GCC)。
驱动程序首先运行C 预处理器(cpp)，它将C的源程序 main.c翻译成一个ASCII码的中间文件 main.i;s
cpp [other arguments] main.c /tep/main.i
```

```
接下来，驱动程序运行C 编译器(ccl)，它将 main.i 翻译成一个 ASCII 汇编文件 main.s 

ccl /tmp/main.i -Og[other arguments] -o /tmp/main.s
```

```
然后，驱动程序运行汇编器(as),它将 main.s 翻译成一个可重定位目标文件(relocatable object file)

as[other arguments] -o /tmp/main.o /tmp/main.s
```

```
驱动程序经过相同过程生成 sum.o。 最后，它运行链接器程序 ld, 将 main.o 和 sum.o 以及一些必要的系统目标文件组合起来，创建一个可执行目标文件(executable object file)prog.

ld -o grog [system object files and args] /tmp/main.o /tmp/sum.o

要运行可执行文件 prog,我们在 linux shell 的命令行上输入它的名字：

linux> ./prog

shell 调用操作系统中一个叫做加载器(loader)的函数，它将可执行文件 prog 中的代码和数据复制到内存，然后将控制转移到这个程序的开头。
```



## 2、静态链接

```
先 linux LD 程序这样的静态链接器(static linker)以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。

输入的可重定位目标文件由各种不同的代码和数据节(section)组成，每一节都是一个连续的字节序列。
指令在一节中，初始化了的全局变量在另一节中，而未初始化的变量又在另外一节中。
```



```
为了构造可执行文件,链接器必须完成两个主要任务：

符号解析(symbol resolution)。
	目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量(即C语言中任何以 static 属性声明的变量)。
	符号解析的目的是将每个符号引用正好和一个符号定义关联起来。
	

重定位(relocation)
	编译器和汇编器生成从地址0开始的代码和数据节。
	链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。
	链接器使用汇编器产生的重定位条目(relocation entry)的详细指令，不加甄别的执行这样的重定位。
```

```
接下来的章节将更加详细的描述这些任务。在你阅读的时候，要记住关于链接器的一个基本事实：
目标文件纯粹是字节块的集合。
这些块中，有些包含程序代码，有些包含程序数据，而其他的则包含引导链接器和加载器的数据结构。
链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。
```



## 3、目标文件

```
目标文件有三种形式：
可重定位目标文件。
	包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。	
	
可执行目标文件。
	包含二进制代码和数据，其形式可以被直接复制到内存并执行。

共享目标文件。
	一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态的加载进内存并链接。
```

```
编译器和汇编器生成可重定位目标文件(包括共享目标文件)。
链接器生成可执行目标文件。
从技术上来说，一个目标模块(object module)就是一个字节序列，而一个目标文件(object file)就是一个以文件形式存放在磁盘中的目标模块。
不过我们会互换的使用这些术语。

```

```
目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。

从贝尔实验室诞生的第一个Unix 系统使用的是 a.out 格式(直到今天，可执行文件仍然称为 a.out 文件)。
现在 x86-64Linux 和Unix 系统使用可执行可链接格式(executable and Linkable format, ELF)。
尽管我们的讨论集中在ELF上，但是不管是哪种格式，基本的概念是相似的。
```



## 4、可重定位目标文件

![](images07-01/01-03.jpg)



```
图7-3展示了一个典型的ELF可重定位目标文件的格式。
ELF头(ELF header)以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。

ELF头剩下的部分包含帮助链接器语法分析和解析目标文件的信息。
其中包括ELF头的大小、目标文件的类型(如可重定位、可执行或共享的)、机器类型(如x86-64)、节头部表(section header table)的文件偏移，以及节头部表条目的大小和数量。

不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目(entry)
```

```
加载ELF头和节头部表之间的都是节。
一个典型的ELF可重定位目标文件包含下面几个节：

.text: 已编译程序的机器代码

.rodata: 只读数据，比如 printf 语句中的格式串和开关语句的跳转表。

.data: 已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，既不出现在 .data节中，也不出现在 .bss 节中。

better save space
.bss: 未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占据实际空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。在运行时，在内存中分配这些变量，初始化值为0.

.symtab: 一个符号表，它存放 在程序中定义和引用的函数和全局变量的信息。.symtab 符号表不包括局部变量的条目。
每个重定位目标文件在 .symtab 中都有一张符号表。

.rel.text: 一个.text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。
一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。
另一方面，调用本地函数的指令则不需要修改。
注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式的指示链接器包含这些信息。

.rel.data: 被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。

.debug: 一个调式符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。

.line: 原始C源程序中的行号和 .text 节中机器指令之间的映射。只有以-g 选项调用编译器驱动程序时，才会得到这张表。

.strtab: 一个字符表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部的节名字。
字符串表就是以 null 结尾的字符串的序列。
```

```
为什么未初始化的数据称为 .bss

用术语.bss 来表示未初始化的数据是很普遍的。它起始于 IBM 704汇编语言(大约在1957年)中"块存储开始(Block Storage Start)"指令的首字母缩写，并沿用至今。
一种记住 .data和.bss节之间区别的简单方法就是吧"bss"看成是"更好的节省空间 better save space"的缩写。
```



## 5、符号和符号表

```
每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。
在链接器上下文中，有三种不同的符号：
	
	由模块m定义并能被其他模块引用的全局符号。全局链接器符号 对应于非静态的C函数和全局变量。
	
	由其他模块定义并被模块m引用的全局符号。这些符号称为外部符号，对应于在其他模块中定义的非静态C函数和全局变量。
	
	只被模块m定义和引用的局部符号。它们对应于带 static 属性的C函数和全局变量。这些符号在模块m中任何位置可见，但是不能被其他模块引用。
	
	这里的定义为就是 例子的意思吧
	全局符号 例子：比如 非静态的C函数和全局变量。
```

```
认识到本地链接器符号和本地程序变量不同是很重要的。
.symtab 中的符号表不包含对应于本地非静态程序变量的任何符号。
这些符号在运行时在栈中被管理，链接器对此类符号不感兴趣。
```

```
C  static 的本地过程变量是不在栈中管理的。
相反，编译器在.data或.bss中为每个定义分配空间，并在符号表中 创建一个有唯一名字的本地链接器符号。
```

![](images07-01/01-04.jpg)



```
符号表是由汇编器构造的，使用编译器输出到汇编语言 .s 文件中的符号。
.symtab 节包含 ELF符号表。这张符号表包含一个条目的数组。
图7-4展示了每个条目的格式。
```

![](images07-01/01-05.jpg)



```
name 是字符串表中的字节偏移，指向符号的以 null 结尾的字符串名字。
这些表里面的str 都是存在 strtab 节中的，所以名字也是

value是符号的地址。对于可重定位的模块来说，value是距定义目标的节的起始位置的偏移。
对于可执行目标文件来说，该值是一个绝对运行时地址。
value 指的应该是比如这个符号定义在 .data, 就是 .data节的起始位置的偏移。
也就是在 .data这个偏移量那里定义了这个符号。


size： 是目标的大小(以字节为单位)。应该是符号的大小

type：通常是要么是数据，要么是函数


符号表还可以包含各个节的条目，以及对应原始源文件的路径名的条目。
所以这些目标的类型也有所不同。

binding 字段表示符号是本地的还是全局的。 
```

```
每个符号都被分配到目标文件的某个节，由 section 字段表示，该字段也是一个到节头部表的索引。
有三个伪节(pseudo section), 它们在节头部表中是没有条目的：
ABS 代表不该被重定位的符号; 
UNDEF 代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号;
COMMON 表示还未被分配位置的未初始化的数据目标。

对于COMMON符号，value字段给出对齐要求，而size给出最小的大小。

注意，只有可重定位目标文件中才有这些伪节，可执行目标文件中是没有的。
```

```
COMMON 和 .bss 的区别很细微。现代的GCC版本根据以下规则来将可重定位目标文件中的符号分配到 COMMON 和 .bss中：
COMMON   未初始化的全局变量
.bss     未初始化的静态变量，以及初始化为0的全局或静态变量

采用这种看上去很绝对的区分方式的原因来自于链接器执行符号解析的方式，我们会在 7.6节中加以解释。
```



## 6、符号解析

```
链接器解析符号引用的方法是 将每个引用与 它输入的可重定位目标文件的符号表中的一个确定的符号定义 关联起来。

对于那些 引用和定义 都是在相同模块中的局部符号的引用，符号解析是非常简单明了的。
编译器只允许每个模块中每个局部符号有一个定义。
静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。

局部变量就是 static 修饰的变量， 全局变量就是 没有static修饰的变量。
外部变量就是被其他模块定义 并被本模块引用的变量，在本模块称为外部变量
```

```
不过，对全局符号的引用解析就棘手的多。
当编译器遇到一个不是在当前模块中定义的符号(变量或函数名)时，会假设该符号是在其他模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。
如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条(通常很难阅读的)错误信息并终止。

比如：
```

![](images07-01/01-06.jpg)

![](images07-01/01-07.jpg)



### 1、链接器如何解析多重定义的全局符号

```
链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部的(只对定义该符号的模块可见)，有些是全局的(对其他模块也可见)。
如果多个模块定义同名的全局符号，会发生什么呢？
下面是Linux编译系统采用的方法。
```

```
在编译时，编译器会向汇编器输出每个全局符号，或者是强(strong)或者是弱(weak),而汇编器把这个信息隐含的编码在可重定位目标文件的符号表里。

函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。
```

```
根据强弱符号的定义，Linux 链接器使用下面的规则来处理多重定义的符号名：
规则 1：不允许有多个同名的强符号。
规则 2：如果有一个强符号和多个弱符号同名，那么选择强符号
规则 3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个。
```

![](images07-01/01-08.jpg)

![](images07-01/01-09.jpg)

![](images07-01/01-10.jpg)

![](images07-01/01-11.jpg)

![](images07-01/01-12.jpg)

![](images07-01/01-13.jpg)



```
在7.5节中，我们看到了编译器如何按照一个看似绝对的规则来吧符号分配为 COMMON 和 .bss。

实际上，采用这个惯例是由于在某些情况中链接器允许多个模块定义同名的全局符号。
当编译器在翻译某个模块时，遇到一个弱全局符号，
	比如说 x，它并不知道其他模块是否也定义了 x, 如果是，它无法预测链接器该使用 x的多重定义中的哪一个。
	所以编译器把x分配成 COMMON，把决定权留给链接器。另一方面，如果x初始化为0，那么它是一个强符号(因此根据规则2必须是唯一的)，所以编译器可以很自信的将它分配成 .bss。类似的，静态符号的构造就必须是唯一的，所以编译器可以自信的把它们分配成 .data 或 .bss。
```



### 2、与静态库链接

![](images07-01/01-14.jpg)

![](images07-01/01-15.jpg)

![](images07-01/01-16.jpg)

![](images07-01/01-17.jpg)



### 3、链接器如何使用静态库来解析引用

```
在linux系统中，静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中。
存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。
存档文件名由后缀 .a 标识。
```



```
虽然静态库很有用，但是它们同时也是一个程序员迷惑的源头，原因在于 Linux链接器使用它们解析外部引用的方式。

在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。
(驱动程序自动将命令行中所有的 .c 文件翻译为 .o 文件。)

在这次扫描中，链接器维护一个可重定位目标文件的集合E(这个集合中的文件会被合并起来形成可执行文件)，

一个未解析的符号(即引用了但是尚未定义的符号)集合U。

以及一个在前面输入文件中已定义的符号集合D。

初始时， E U D 均为空。
```

```
对于命令行上的每个输入文件 f, 链接器会判断 f 是一个目标文件还是一个存档文件。
如果 f 是一个目标文件，那么链接器把f添加到E，修改U和D来反映f中符号定义和引用，并继续下一个输入文件。
```

```
如果 f 是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。

如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器修改U和D来反映m中的符号定义和引用。

对存档文件中所有的成员目标文件都依次进行这个过程，直到U和D都不再发生变化。
	
此时，任何不包含在E中的成员目标文件都简单的被丢弃，而链接器将继续处理下一个输入文件。
```

```
	如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一个错误并终止。
	否则，它会合并和重定位E中的目标文件，构建输出的可执行文件。
```



```
不幸的是，这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺序非常重要。
在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接就会失败。
```

![](images07-01/01-18.jpg)



## 7、重定位

```
一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义(即它的一个输入目标模块中的一个符号表条目)关联起来。
此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。

现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。
```

```
重定位有两步组成：

重定位 节和符号 定义：
在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。

例如，来自所有输入模块的 .data 节被全局合并成一个节，这个节成为输出的可执行目标文件的 .data 节。
然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。
当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。



重定位节中的符号引用：
	在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。
要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目(relocation entry)的数据结构，我们接下来将会描述这种数据结构。
```



### 1、重定位条目

```
当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。
它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。
所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时 如何修改这个引用。
代码的重定位条目放在 rel.text 中。
已初始化数据的重定位条目放在 .rel.data 中。
```



![](images07-01/01-19.jpg)

```
图7-9展示了 ELF 重定位条目的格式。 
offset 是需要被修改的引用的节 的偏移。
symbol 标识被修改的引用应该指向的符号。
type 告知链接器如何修改新的引用。
addend 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。
```

```
ELF 定义了 32 种不同的重定位类型，有些想当隐秘。我们只关心其中两种最基本的重定位类型：

R_X86_64_PC32:
	重定位一个使用32位PC相对地址的引用。回想一下3.6.3节，一个PC相对地址就是距程序计数器(PC)的当前运行时值的偏移量。
当CPU执行一条使用PC相对寻址的指令时，它就将在指令中编码的32位值加上PC的当前运行时值，得到有效地址(如call指令的目标)，PC值通常是下一条指令在内存中的地址。

R_X86_64_32:
	重定位一个使用32位绝对地址的引用。通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改。
```

![](images07-01/01-20.jpg)





### 2、重定位符号引用

![](images07-01/01-21.jpg)

![](images07-01/01-22.jpg)



![](images07-01/01-23.jpg)





























