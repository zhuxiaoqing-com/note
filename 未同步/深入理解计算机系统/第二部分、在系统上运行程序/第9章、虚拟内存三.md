## 8、内存映射

### 12、综合：实现一个简单的分配器

```
构造一个分配器是一件富有挑战性的任务。
设计空间很大，有多种块格式、空闲链表格式，以及放置、分割和合并策略可供选择。

另一个挑战就是你经常被迫在类型系统的安全和熟悉的限定之外编程，依赖于容易出错的指针强制类型转换的指针运算，这些操作都属于典型的底层系统编码。
```

![](images09-01-03/01-01.jpg)

#### 1、通用分配器设计

![](images09-01-03/01-02.jpg)

```
我们的分配器使用如图9-41所示的 memlib.c 包所提供的的一个内存系统模型。模型的目的在于允许 我们在不干涉已存在的系统层 malloc 包的情况下，运行分配器。
```

```
mem_init 函数将对于堆来说可用的虚拟内存模型化为一个大的、双字对齐的字节数组。
在mem_heap和mem_brk 之间的字节表示已分配的虚拟内存。
mem_brk 之后的字节表示未分配的虚拟内存。
分配器通过调用 mem_sbrk 函数来请求额外的堆内存，这个函数和系统的 sbrk 函数的接口相同，而且语义也相同，除了它会拒绝收缩堆的请求。
```

![](images09-01-03/01-03.jpg)

```
mm_init 函数初始化分配器，如果成功就返回0，否则就返回 -1。
mm_malloc 和 mm_free 函数与它们对应的系统函数有相同的接口和语义。
分配器使用如图 9-39所示的块格式。
最小块的大小为 16 字节。
空闲链表组织成为一个隐式空闲链表，具有如图 9-42所示的恒定形式。
```

![](images09-01-03/01-04.jpg)

```
第一个字是一个双字边界对齐的不使用的填充字。
填充后面紧跟着一个特殊的序言块(prologue block),
这是一个8字节的已分配块，只由一个头部和一个脚部组成。
序言块是在初始化时创建的，并且永不释放。
在序言块后紧跟着零个或者多个由 malloc 或者 free 调用创建的普通块。
堆总是以一个特殊的结尾块(epilogue block)来结束，这个块是一个大小为零的已分配块，只由一个头部组成。

序言块和结尾块是一种消除合并时边界的条件的技巧。
分配器使用一个单独的私有(static)全局变量(heap_listp),它总是指向序言块。(作为一个小优化，我们可以让它指向下一个块，而不是整个序言块。)
```



#### 2、操作空闲链表的基本常数和宏

![](images09-01-03/01-05.jpg)

![](images09-01-03/01-06.jpg)

![](images09-01-03/01-07.jpg)



#### 3、创建初始化空闲链表

![](images09-01-03/01-08.jpg)

![](images09-01-03/01-09.jpg)

```
在调用 mm_malloc 或者 mm_free 之前，应用必须调用 mm_init 函数来初始化堆(见图9-44)。 
```

```
mm_init 函数从内存系统得到4个字，并将它们初始化，创建一个空的空闲链表(第4~10行)。
然后它调用 extendheap 函数(图9-45)，这个函数将堆扩展 CHUNKSIZE 字节，并且创建初始的空闲块。
此刻分配器已经初始化了，并且准备好接收来自应用的分配和释放请求。
```

```
extend_heap 函数会在两种不同的环境中被调用：
1、当堆被初始化时;
2、当mm_malloc 不能找到一个合适的匹配块时。
为了保持对齐，extend_heap 将请求大小向上舍入为最接近的2字(8字节)的倍数，然后向内存系统请求额外的堆空间(请求7~9行)。
```

```
extend_heap 函数的剩余部分(第12~17行)有点儿微妙。
堆开始于一个双字对齐的边界，并且每次对 extend_heap 地调用都返回一个块，该块的大小时双字的整数倍。
因此，对 mem_sbrk 的每次调用都返回一个双字对齐的内存片，紧跟在结尾块的头部后面。
这个头部变成了新的空闲块的头部(第12行)，并且这个片的最后一个字变成了新的结尾块的头部(第14行)。
最后，在很有可能出现的前一个堆以一个空闲块结束的情况下中，我们调用 coalesce 函数来合并两个空闲块，并返回指向合并后的块的块指针(第17行)。
```



#### 4、释放和合并块

![](images09-01-03/01-10.jpg)

![](images09-01-03/01-11.jpg)

```
应用通过调用 mm_free 函数(图9-46)来释放一个以前分配的块，这个函数释放所请求的块(bp),然后使用 9.9.11 节中描述的边界标记合并技术将之与邻接的空闲块合并起来。
```

```
coalesce 函数中的代码是图9-40中勾画的四种情况的一种简单的实现。
这里有一个微妙的方面。
我们选择的空闲链表格式(它的序言块和结尾块总是标记为已分配)允许我们忽略潜在的麻烦边界情况，也就是，请求块bp 在堆的起始处或者是在堆的结尾处。
如果没有这些特殊块，代码将换乱的多，更加容易出错，并且更慢，因为我们不得不在每次释放请求时，都去检查这些并不常见的边界情况。
```

#### 5、分配块

![](images09-01-03/01-12.jpg)

```
一旦分配器调整了请求的大小，它就会搜索空闲链表，寻找一个合适的空闲块(第18行)。
如果有合适的，那么分配器就放置这个请求块，并可选的分割出多余的部分(第19行)，然后返回新分配的地址。
```

```
如果分配器不能够发现一个匹配的块，那么就用一个空闲块来扩展堆(第24-26行)，把请求块放置在这个新的空闲块里，可选的分割这个块(第27行)，然后返回一个指针，指向这个新分配的块。
```

![](images09-01-03/01-13.jpg)

![](images09-01-03/01-14.jpg)

![](images09-01-03/01-15.jpg)



### 13、显式空闲链表

