**网络编程**

## 1、客户端-服务器编程模式

```
每个网络应用都是基于客户端-服务器模型的。
采用这个模型，一个应用是由一个服务器进程和一个或者多个客户端进程组成。
服务器管理某种资源，并且通过操作这种资源来为它的客户端提供某种服务。

例如，一个web服务器管理着一组磁盘文件，它会代表客户端进行检索和执行。
一个FTP服务器管理着一组磁盘文件，它会为客户端进行存储和检索。
相似的，一个电子邮件服务器管理着一些文件，它为客户端进行读和更新。
```

```
客户端-服务器模式中的基本操作是事务(transaction)(见图11-1)。
一个客户端-服务器事务由以下四步组成。

1)当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务。
例如，当Web服务器需要一个文件时，它就发送一个请求给web服务器。

2)服务器收到请求后，解释它，并以适当的方式操作它的资源。
例如，当web服务器收到浏览器发出的请求后，它就读一个磁盘文件。

3)服务器给客户端发送一个响应，并等待下一个请求。
例如，web服务器将文件发送回客户端。

4)客户端收到响应并处理它。
例如，当web浏览器收到来自服务器的一页后，就在屏幕上显示此页。
```

![](images11-01/01-01.jpg)

```
认识到客户端和服务器是进程，而不是常提到的机器或者主机，这是很重要的。
一台主机可以同时运行许多不同的客户端和服务器，而且一个客户端和服务器的事务可以在一台或是不同的主机上。无论客户端和服务器是怎样映射到主机上的客户端-服务器模型都是先相同的。
```

![](images11-01/01-02.jpg)

## 2、网络

```
客户端和服务器通常运行在不同的主机上，并且通过计算机网络的硬件和软件资源来通信。
网络是很复杂的系统，在这里我们只想了解一点皮毛。
我们的目标是从程序员的角度给你一个切实可行的思维模型。

对主机而言，网络只是又一种I/O设备，是数据源和数据接收方，如图11-2所示。
```

![](images11-01/01-03.jpg)

```
一个插到I/O总线扩展槽的适配器提供了到网络的物理接口。
从网络上接收到的数据从适配器经过I/O和内存总线复制到内存，通常是通过DMA传送。
相似的，数据也能从内存复制到网络。
```

```
物理上而言，网络是一个按照地理远近组成的层次系统。
最底层是 LAN(Local Area Network,局域网)，在一个建筑或者校园范围内。
迄今为止，最流行的局域网技术是以太网(Ethernet),它是由施乐公司帕洛阿尔托研究中心(Xerox PARC)在20世纪70年中期提出的。
以太网技术被证明是适应力极强的，从3Mb/s 演变到了 10Gb/s。
```

![](images11-01/01-04.jpg)

```
一个以太网段(Ethernet segment)包括一些电缆(通常是双绞线)和一个叫做集线器的小盒子，如图11-3所示。
以太网通常跨越一些小的区域，例如某建筑物的一个房间或者一个楼层。
每根电缆都有相同的最大位带宽，通过是100Mb/s 或者 1Gb/s。
一端连接到主机的适配器，而另一端则连接到集线器的一个端口上。
集线器不加分辨的将从一个端口上收到的每个位复制到其他所有的端口上。
因此，每台主机都能看到每个位。
```

```
每个以太网适配器都有一个全球唯一的48位地址，它存储在这个适配器的非易失性存储器上。
一台主机可以发送一段位(称为帧(frame))到这个网段内的其他任何主机。
每个帧包括一些固定数量的头部(header)位,用来标识此帧的源和目的地址以及此帧的长度，此后紧随的就是数据位的有效载荷(payload)。
每个主机适配器都能看到这个帧，但是只有目的主机实际读取它。
```

```
使用一些电缆和佳作网桥(bridge)的小盒子，多个以太网段可以连接成较大的局域网，称为桥接以太网(bridge Ethernet), 如图11-4所示。
桥接以太网能够跨越整个建筑物或者校区。
再一个桥接以太网里，一些电缆连接网桥与网桥，而另外一些连接网桥和集线器。
这些电缆的带宽可以是不同的。
在我们的示例中，网桥与网桥之间的电缆有1Gb/s 的带宽，而四根网桥和集线器之间电缆的带宽却是100Mb/s。
```

![](images11-01/01-05.jpg)

```
集线器连接了一个个网络适配器，成为了一个以太网段，而网桥将一个个集线器，也就是以太网段连接起来，变成了一个以太网。
而最流行的局域网技术就是以太网。
局域网是一个建筑或者一个校园范围内。
```

```
网桥比集线器更充分的利用了电缆带宽。
利用一种聪明的分配算法，它们随着时间自动学习哪个主机可以通过哪个端口可达。
例如，如果主机A发送一个帧到同网段上的主机B, 当该帧到达网桥X的输入端口时，X就讲丢弃此帧，因而节省了其他网段上的带宽。
然而，如果主机A发送一个帧到一个不同网段上的主机C，那么网桥X只会把此帧复制到和网桥Y相连的端口上，网桥Y只会把此帧复制到与主机 C 的网段连接的端口。 
```

```
为了简化局域网的表示，我们将把集线器和网桥以及连接他们的电缆画成一根水平线，如图11-5所示。
```

![](images11-01/01-06.jpg)



```
在层次的更高级别中，多个不兼容的局域网可以通过叫做路由器(router)的特殊计算机连接起来，组成一个 internet(互联网络)。

每台路由器对于它所连接到的每个网络都有一个适配器(端口)。
路由器也能连接高速点到点电话连接，这是称为 WAN(Wide-Area Network，广域网)的网络示例，之所以这么叫是因为它们覆盖的地理范围比局域网的大。
一般而言，路由器可以用来由各种局域网和广域网构建互联网络。

例如，图11-6 展示了一个互联网络的示例，3台路由器连接了一对局域网和一对广域网。
```

```
一般来说互联网就是国际互联网的简称，国际互联网就是Internet，所以互联网=Internet；
广域网是网络专业的一个专业术语，通常特指跨接很大物理范围的计算机网络，一般要超过几十公里，比如某公司总部在北京，分公司在上海，这两个地方的分别有各自的局域网，这两个局域网通过自建或者租用通讯线路的方式连接起来就构成了一个广域网络。
所以国际互联网是广域网的一种。

广域网是网络的一个类别，国际互联网是广域网的一个实例。就像山羊是一种羊，但是羊不一定就是山羊。
```

![](images11-01/01-07.jpg)

![](images11-01/01-08.jpg)



```
互联网络至关重要的特性是，它能由采用完全不同和不兼容技术的各种局域网和广域网组成。
每台主机和其他每台主机都是物理相连的，但是如何能够让某台主机跨过所有这些不兼容的网络发送数据位到另一台目的主机呢？
```

```
解决方法是一层运行在每台主机和路由器上的协议软件，它消除了不同网络之间的差异。
这个软件实现一种协议，这种协议控制主机和路由器如何协同工作来实现数据传输。

这种协议必须提供两种基本能力：
```

```
命名机制。
	
	不同的局域网技术有不同和不兼容的方式来为主机分配地址。
	互联网络协议通过定义一种一致的主机地址格式消除了这些差异。
	每台主机会被分配至少一个这种互联网络地址(internet address)，这个地址唯一的标识了这台主机。
	
	
传送机制：

	在电缆上编码位和将这些位封装成帧方面，不同的联网技术有不同的和不兼容的方式。
	互联网络协议通过定义一种把数据位捆扎成不连续的片(称为包)的统一方式，从而消除了这些差异。
	一个包是由包头和有效载荷组成的，其中包头包括包的大小以及源主机和目的主机的地址，有效载荷包括从源主机发出的数据位。
```

![](images11-01/01-09.jpg)

```
图11-7展示了主机和路由器如何使用互联网络协议在不兼容的局域网间传送数据的一个示例。
```

```
这个互联网络示例由两个局域网通过一台路由器连接而成。
一个客户端运行在主机 A 上，主机 A 与 LAN1 相连，它发送遗传数据字节到运行在主机 B 上的服务器端，主机 B 则连接在 LAN2 上。
这个过程有 8 个基本步骤：

1、运行在主机 A 上的客户端进行一个系统调用，从客户端的虚拟地址空间复制数据到内核缓冲区中。

2、主机 A 上的协议软件通过在数据前附加互联网络包头和 LAN1 帧头，创建了一个 LAN1 的帧。
互联网络包头寻址到互联网络主机B。
LAN1 帧头寻址到路由器。
然后它传送此帧到适配器。
注意，LAN1帧的有效载荷是一个互联网络包，而互联网络包的有效载荷是实际的用户数据。
这种封装是基本的网络互连方法之一。

3、LAN1 适配器复制该帧到网络上。

4、当此帧到达路由器时，路由器的LAN1 适配器从电缆上读取它，并把它传送到协议软件。

5、路由器从互联网络包头中提取出目的互联网络地址，并用它作为路由表的索引，确定向哪里转发这个包，在本例中是 LAN2。
路由器剥落旧的 LAN1 的帧头，加上寻址到主机 B 的新的 LAN2 帧头，并把得到的帧传送到适配器。

6、路由器的 LAN2 适配器复制该帧到网络上。

7、当此帧到达主机 B 时，它的适配器从电缆上读到此帧，并将它传送到协议软件。

8、最后，主机B上的协议软件剥落包头和帧头。
当服务器进行一个读取这些数据的系统调用时，协议软件最终得到的数据复制到服务器的虚拟地址空间。


包头是用来在路由器上进行路由的 可以用来查找目的主机。相应的局域网适配器应该可以通过 ip 地址找到 用来在局域网里使用的目的主机的  地址的。
局域网包头是用来在局域网范围内寻址的。
```

```
当然，在这里我们掩盖了许多很难的问题。
如果不同的网络有不同帧大小的最大值，该怎么办呢？
路由器如何知道该往哪里转发帧呢？
当网络拓扑变化时，如何通知路由器？
如果一个包丢失了又会如何呢？
虽然如此，我们的示例抓住了互联网络思想的精髓，封装是关键。
```



## 3、全球 IP 因特网

```
全球 IP 因特网是最著名和最成功的互联网络实现。
从 1969 年起，它就一这样或那样的形式存在了。
虽然因特网的内部体系结构复杂而且不断变化，但是自从20世纪80年代早期以来，客户端-服务器应用的组织就一直保持着相当的稳定。

图 11-8 展示了一个因特网客户端-服务器应用程序的基本硬件和软件组织。
```

![](images11-01/01-10.jpg)

```
每台因特网主机都运行实现 TCP/IP协议(transmission Control Protocol/ Internet Protocol, 传输控制协议/互联网络协议)的软件，几乎每个现代计算机系统都支持这个协议。
因特网的客户端和服务器混合使用套接字接口函数和 Unix I/O 函数来进行通信(我们将在 11.4 节中介绍套接字接口)。
通常将套接字函数实现为系统调用，这些系统调用会陷入内核，并调用各种内核模式的 TCP/IP 函数。
```

```
TCP/IP 世纪是一个协议族，其中每一个都提供不同的功能。
例如, IP 协议提供基本的命名方法和递送机制，这种递送机制能够从一台因特网主机往其他主机发送包，也叫做数据报(datagram)。
IP 机制从某种意义上而言是不可靠的，因为，如果数据报在网络中丢失或者重复，它并不会试图恢复。
UDP(Unreliable Datagram Protocol, 不可靠数据报协议)稍微扩展了 IP 协议，这样一来，包可以在进程间而不是在主机间传送。
TCP(Transimission Control Protocol) 是一个构建在 IP 之上的复杂协议，提供了进程间可靠得的全双工(双向的)连接。
为了简化讨论，我们将TCP/IP 看做是一个单独的整体协议。
我们将不讨论它的内部工作，值讨论TCP和IP为应用程序提供的某些基本功能。
我们将不讨论UDP。

从程序员的角度，我们可以吧因特网看做一个世界范围的主机集合，满足以下特性：
1、主机集合被映射为一组32位的IP地址。
2、这组IP地址呗映射为一组称为因特网域名(Internet domain name)的标识符。
3、因特网主机上的进程能够通过连接(connection)和任何其他因特网主机上的进程通信。

接下来三节将更加详细地讨论这些基本的因特网概念。
```

![](images11-01/01-11.jpg)



### 1、IP地址

```
一个IP地址就是一个32位无符号整数。
网络程序IP地址存放在如图11-9所示的IP地址结构中。
```

![](images11-01/01-12.jpg)

```
标量类型（Scalar type）是相对复合类型（Compound type）来说的：标量类型只能有一个值，而复合类型可以包含多个值。复合类型是由标量类型构成的。

在C语言中，整数类型（int、short、long等）、字符类型（char、wchar_t等）、枚举类型（enum）、小数类型（float、double等）、布尔类型（bool）都属于标量类型，一份标量类型的数据只能包含一个值。例如：
```

```
把一个标量地址存放在结构中，是套接字接口早期实现的不幸产物。
为IP地址定义一个标量类型应该更有意义，但是现在更改已经太迟了，因为已经有大量应用是基于此的。
```

```
因为因特网主机可以有不同的主机字节顺序，TCP/IP 为任意整数数据项定义了统一的网络字节顺序(network byte  order)(大端字节顺序)，例如IP地址，它放在包头中跨过网络被携带。
在IP地址结构中存放的地址总是以(大端法)网络字节顺序存放的，即使主机字节顺序(host byte order)是小端法。
Unix 提供了下面这样的函数在网络和主机字节顺序间实现转换。
```

![](images11-01/01-13.jpg)

```
n 代表 network
h 代表 host
```

```
htonl 函数将 32 位整数由主机字节顺序转换为网络字节顺序。
ntohl 函数将 32 位整数从网络字节顺序转换为主机字节顺序。
htons 和 ntohs 为 16位无符号整数执行相应的转换。
注意没有对应的处理64位值的函数。
```

```
点分十进制表示法：
每一组数字都是十进制，组与组之间用"."分隔
区别于ipv6的冒分16进制 internet protocol version 6
就是用冒号分隔每一组数，每组数用16进制表示

IP地址通常是以一种称为 点分十进制表示法 来表示的，这里, 每个字节由它的十进制值表示，并且用句点和其他字节间分开。

例如, 128.2.194.242 就是地址 0x8002c2f2 的点分十进制表示。
在Linux 系统上，你能够使用 HOSTNAME 命令来确定你自己主机的点分十进制地址：
```

![](images11-01/01-14.jpg)

```
在这些函数名中，"n"代表网络，"p"代表表示。
它们可以处理32位 IPv4 地址(AF_INET(就像这里展示的那样))，
或者128位 IPv6 地址(AF_INET6)(这部分我们不讲)。
```

```
	inet_pton函数将一个点分十进制串(src)转换为一个二进制的网络字节顺序的IP地址(dst)。
	如果 src 没有指向一个合法的点分十进制字符串，那么该函数就返回 0。
	任何其他错误会返回-1，并设置 errno。
	相似的， inet_ntop 函数将一个二进制的网络字节顺序的IP地址(src)转换为它所对应的点分十进制表示，并把得到的以null结尾的字符串的最多 size 个字节复制到 dst。
```

![](images11-01/01-15.jpg)

![](images11-01/01-16.jpg)

![](images11-01/01-17.jpg)



### 2、因特网域名

```
因特网客户端和服务器互相通信时使用的是 IP 地址。
然而，对于人们而言，大整数是很难记住的，所以因特网也定义了一组更加人性化的域名(domain name),以及一种将域名映射到 IP 地址的机制。
域名是一串用句点分隔的单词(字母、数字和破折号)，例如 www.baidu.com 。

域名集合形成了一个层次结构，每个域名编码了它在这个层次中的位置。
通过一个示例你将很容易理解这点。
```

![](images11-01/01-18.jpg)

```
图11-10展示了域名层次结构的一部分。
层次结构可以表示为一棵树。
树的节点表示域名，反向到根的路径形成了域名。
子树称为子域(subdomain)。
层次结构中的第一层是一个未命名的根节点。

下一层是一组一级域名(first-level domain name),由非营利组织 ICANN 定义。
常见的第一层域名包括 com、edu、gov、org 和 net。

下一层是二级(second-level)域名，例如 cmu.edu,这些域名是由 ICANN 的各个授权代理按照先到先服务的基础分配的。
一旦一个组织得到了一个二级域名，那么它就可以在这个子域中创建任何新的域名了，例如 cs.cmu.edu。
```

```
因特网定义了域名集合和IP地址集合之间的映射。
知道1988年，这个映射都是通过一个叫做 HOSTS.TXT 的文本文件来手工维护的。
从那以后，这个映射是通过分布世界范围内的数据库(称为 DNS(Domain name system, 域名系统))来维护的。
从概念上而言，DNS数据库由上百万的主机条目结构(host entry structure)组成，其中每条定义了一组域名和一组IP地址之间的映射。
从数学意义上来讲，可以认为每条主机条目就是一个域名和IP地址的等价类。
```

```
我们可以用 Linux 的 NSLOOKUP 程序来探究 DNS 映射的一些属性，这个程序能展示与某个 IP 地址对应的域名。
```

![](images11-01/01-19.jpg)

```
在最简单的情况中，一个域名和一个IP地址之间是一一映射：
```

![](images11-01/01-20.jpg)

```
然而，在某些情况下，多个域名可以映射为同一个 IP 地址：
```

![](images11-01/01-21.jpg)

```
在最通常的情况下，多个域名可以映射到同一组的多个IP地址：
```

![](images11-01/01-22.jpg)

```
最后，我们注意到某些合法的域名没有映射到任何IP地址：
```

![](images11-01/01-23.jpg)

![](images11-01/01-24.jpg)

### 3、因特网连接

```
因特网客户端和服务器通过在连接上发送和接受字节流来通信。
从连接一堆进程的意义上而言，连接是点对点的。
从数据可以同时双向流动的角度而言，它是全双工的。
并且从(物理上损害以外)由源进程发出的字节流最终被目的进程以它发出的顺序收到它的角度来说，它是可靠的。
```

```
一个套接字是连接的一个端点。
每个套接字都有相应的套接字地址，是由一个因特网地址和一个16位正式端口组成的，用 "地址：端口"来表示。

当客户端发起一个连接请求时，客户端套接字地址中的端口是由内核自动分配的，称为临时端口(ephemeral port)。
然而，服务器套接字地址中的端口通常是某个知名端口，是和这个服务相对应的。
例如，Web 服务器通常是使用端口 80，而电子邮件服务器使用端口25。
每个具有知名端口的服务都有一个对应的知名的服务名。
例如，Web服务的知名名字是 http， email 的知名名字是 smtp。
文件 /etc/services 包含一张这台机器提供的知名名字和知名端口之间的映射。

ip   对应于 domain name
port 对应于 服务名  例如：80 对应 http 
```

```
一个连接是由它两端的套接字地址唯一确定的。
这对套接字地址叫做套接字对(socket pair)，由下列元组来表示：
(cliaddr:cliport, servaddr:servport)
cliaddr 是由客户端的 IP 地址， 
cliport 是客户端的端口， 
servaddr 是服务器的IP地址， 
servport 是服务器的端口 

例如，图11-11 展示了一个  Web 客户端和一个 web 服务器之间的连接。
```

![](images11-01/01-25.jpg)

![](images11-01/01-26.jpg)

![](images11-01/01-27.jpg)

```
ARPANET
TCP/IP标准协议
DNS
NSFNET
现代因特网架构
```



## 4、套接字接口

```
套接字接口(socket interface)是一组函数，它们和 Unix I/O 函数结合起来，用以创建网络应用。
大多数现代系统上都实现套接字接口，包括所有的 Unix 变种、Windows 和 Macintosh 系统。
图11-12 给煮了一个典型的客户端-服务器事务的上下文中的套接字接口概述。
当讨论各个函数时，你可以使用这张图来作为向导图。
```

![](images11-01/01-28.jpg)

![](images11-01/01-29.jpg)

### 1、套接字地址结构

```
从 Linux 内核的角度来看，一个套接字就是通信的一个端点。
从 Linux 程序的角度来看，套接字就是一个有相应描述符的打开文件。
```

```
因特网的套接字地址存放在如图 11-13 所示的类型为 sockaddr_in 的16字节结构中。
对于因特网应用，sin_family(协议类型) 成员是 AF_INET, 
sin_port 成员是一个16位端口号，
而 sin_addr 成员就是一个32位的IP地址。
IP地址和端口号总是以网络字节顺序(大端法)存放的。
```

![](images11-01/01-12.jpg)

![](images11-01/01-30.jpg)

![](images11-01/01-31.jpg)

```
connect、bind 和 accept 函数要求一个指向与协议相关的套接字地址结构的指针。
套接字结构的设计者面临的问题是，如何定义这些函数，使之能接受各种类型的套接字地址结构。
今天我们可是使用通用的 void* 指针，但是那时在 C 中并不存在这种类型的指针。
解决办法是定义套接字函数要求一个指向通用 sockaddr 结构(图11-13)的指针，
首先，创建sockaddr_in 然后将 sockaddr_in 强制转换为 sockaddr 这个通用结构，
然后要求应用程序将与协议特定的结构的指针强制转换成这个通用结构。
```

![](images11-01/01-32.jpg)

```
为什么 sockaddr_in 和 sockaddr 可以互相转换？
因为他们的内存一样大。
```

![](images11-01/01-33.jpg)

![](images11-01/01-34.jpg)

![](images11-01/01-35.jpg)

```
sockaddr_in 和 sockaddr  内存一样大 可以互相转换，那么 sockaddr_in6 呢？
sockaddr_in6 有28字节。
```

```
其实 sockaddr 和 sockaddr_in 之间的转换很容易理解，因为他们开头一样，内存大小也一样，但是 sockaddr 和 sockaddr_in6 之间的转换就有点让人搞不懂了，其实你有可能被结构所占的内存迷惑了，这几个结构在作为参数时基本上都是以指针的形式传入的。
我们拿函数 bind() 为例，这个函数一共接收三个参数，
第一个为监听的文件描述符，
第二个参数时 sockaddr* 类型，
第三个参数时传入指针原结构的内存大小，
所以有了后两个信息，无所谓结构怎样变化，因为他们的头都是一样的，也就是 uint16 sa_family, 那么我们也能根据这个头做处理。

原本我没有看过 bind()函数的的源代码，但是可以猜想一下：
```

![](images11-01/01-36.jpg)



### 2、socket 函数

```
客户端和服务器使用 socket 函数来创建一个套接字描述符(socket descriptor)。
```

![](images11-01/01-37.jpg)

```
如果想要使套接字成为连接的一个端点，就用如下硬编码的参数来调用 socket 函数：
domain 是使用的协议类型 是32位IP地址还是64位IP地址。

type 为数据传输方式/套接字类型，常用的有 SOCK_STREAM（流格式套接字/面向连接的套接字） 和 SOCK_DGRAM（datagram 数据报套接字/无连接的套接字）

protocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议。

正如大家所想，一般情况下有了 af 和 type 两个参数就可以创建套接字了，操作系统会自动推演出协议类型，除非遇到这样的情况：有两种不同的协议支持同一种地址类型和数据传输类型。如果我们不指明使用哪种协议，操作系统是没办法自动推演的。
所以 protocol 也可以直接填 0。socket方法会自动推断出 protocol是哪种类型的。

clinetfd = Socket(AF_INET, SOCK_STREAM, 0);
其中，AF_INET 表明我们正在使用 32 位 IP 地址，而 SOCK_STREAM 表示这个套接字是连接的一个端点。
不过最好的方法是用 getaddrinfo 函数(11.4.7节)来自动生成这些参数，这样代码就与协议无关了。
我们会在 11.4.8节中向你展示如何配合 socket 函数来使用 getaddrinfo。
```

```
socket 返回的 cllentfd 描述符仅是部分打开的，还不能用于读写。
如何完成打开套接字的工作，取决于我们是客户端还是服务器。
下一节描述当我们是客户端时如何完成的打开套接字的工作。
```



### 3、connect 函数

![](images11-01/01-38.jpg)

```
connect 函数试图与套接字地址为 addr 的服务器建立一个因特网连接，其中 addrlen 是 sizeof(sockaddr_in)。
connect 函数会阻塞，一直到连接成功建立或是发生错误。
如果成功，clientfd 描述符现在就准备好可以读写了，并且得到的连接是由套接字对 (x:y, addr.sin_addr:addr.sin_port)
刻画的，其中 x 表示客户端的 IP 地址，而 y 表示临时端口，它唯一的确定了客户端主机上的客户端进程。
对于 socket, 最好的方法是用 getaddrinfo 来为 connect 提供参数(见11.4.8节)。
```



### 4、bind 函数

[bind函数详解](http://www.voidcn.com/article/p-awlovvys-xq.html)

```
剩下的套接字函数 -- bind、listen 和 accpet，服务器用它们来和客户端建立连接。
```

![](images11-01/01-39.jpg)

```
bind 函数是告诉内核将 addr 中的服务器套接字地址和套接字描述符 sockfd 联系起来。

sockaddr *addr 参数详解
sin_family 设置为 AF_INET(IPv4);
sin_port指明端口号;
sin_addr结构体中只有一个唯一的字段s_addr，表示IP地址，该字段是一个整数，一般用函数 inet_addr()吧字符串形式的unsigned long 型的整数值后再置给 s_addr。
有的服务器是多宿主机，至少两个网卡，那么运行在这样的服务器上的服务程序在为其 socket 绑定 IP 地址时可以吧 htonl(INADDR_ANY)置给s_addr，这样做的好处是不论哪个网段上的客户程序都能与该服务程序同信；
如果置给运行在多宿主机上的服务程序的 socket 绑定一个固定ip地址，那么就只有与该ip地址处于同一网段上的客户程序才能与该服务程序通信。

INADDR_ANY就是指定地址为0.0.0.0的地址,这个地址事实上表示不确定地址,或“所有地址”、“任意地址”。 一般来说，在各个系统中均定义成为0值。
```

### 5、listen 函数

```
客户端时发起连接请求的主动实体。
服务器是等待来自客户端的连接请求的被动实体。
默认情况下，内核会认为 socket 函数创建的描述符对应于主动套接字(active socket), 它存在于一个连接的客户端。
服务器调用 listen 函数告诉内核，描述符是被服务器而不是客户端使用的。
```

![](images11-01/01-40.jpg)

 ```
listen 函数将 sockfd 从一个主动套接字转化为一个监听套接字(listening socket), 该套接字可以接受来自客户端端的连接请求。
backlog(积压) 参数暗示了内核在开始决绝连接请求之前，队列中要排队的未完成的连接请求的数量。(简而言之就是，队列中未完成的连接请求的数量超过了 backlog，内核就会拒绝连接请求)。

通常我们会把它设置为一个较大的值，比如 1024。
 ```

### 6、accept 函数

![](images11-01/01-41.jpg)

```
listenfd 是 socket()返回的文件描述符
sockaddr *addr：指向struct sockaddr的指针，用于返回客户端的协议地址
*addrlen：返回协议地址的长度

连接的客户端的协议地址和端口会存放在 sockaddr *addr 里面返回给我们。
```

```
accept 函数等待来自客户端的连接请求到达侦听描述符 listenfd, 然后在 addr 中填写客户端的套接字地址，并返回一个已连接描述符(connected descriptor)，这个描述符可被用来利用 Unix I/O 函数与客户端通信。
```

```
监听描述符和已连接描述符之间的区别使很多人感到迷惑。
监听描述符是作为客户端连接请求的一个端点。
它通常被创建一次，并存在于服务器的整个生命周期。
已连接描述符是客户端和服务器之间已经建立起来了的连接的一个端点。
服务器每次接受请求时都会创建一次，它只存在于服务器为一个客户端服务的过程中。
```

![](images11-01/01-42.jpg)

```
图11-14描绘了监听描述符和已连接描述符的角色。
在第一步中，服务器调用 accept，等待连接请求到达监听描述符，具体的我们设定为描述符3。
回忆一下，描述符0~2是预留给了标准文件的。

在第二步中，客户端调用 connect 函数，发送一个连接请求到 Listenfd。
第三步，accept 函数打开了一个新的连接描述符 connfd(我们假设是描述符4)，在 clientfd 和 connfd 之间建立连接，随后返回 connfd 给应用程序。
客户端也从 connect 返回，在这一点以后，客户端和服务器就可以分别通过读和写 clientfd 和 connfd 来回传送数据了。
```

![](images11-01/01-43.jpg)



### 7、主机和服务的转换

```
Linux 提供了一些强大的函数(称为 getaddrinfo 和 getnameinfo)实现二进制套接字地址结构和主机域名、主机地址(ip地址)、服务名和端口号的字符串表示之间的互相转化。
当和套接字接口一起使用时，这些函数能使我们编写独立于任何特定版本的IP协议的网络程序。
```

#### 1、getaddrinfo 函数

[getaddrinfo 函数详解参考1](https://www.cnblogs.com/zhangsf/p/3145552.html)

[getaddrinfo 函数详解参考2](http://blog.chinaunix.net/uid-11765716-id-390555.htmll)

```
getaddrinfo 函数将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构。

它是已弃用的 gethostbyname 和 getservbyname 函数的新的代替品(这两个函数不支持 ipv6)。
和以前的那些函数不同，这个函数是可重入的(见12.7.2节)，适用于任何协议。
```

![](images11-01/01-44.jpg)

```
1、概述
IPv4中使用 gethsotbyname()函数完成主机名到地址解析，这个函数仅仅支持 IPv4,且不允许调用者指定所需地址类型的任何信息，返回的结构只包含了用于存储IPv4 地址的空间。

IPv6 中引入了 getaddrinfo()的新的API，它是协议无关的，既可用于IPv4也可用于IPv6。
getaddrinfo 函数能够处理名字到地址以及服务到端口这两种转换，返回的是一个addrinfo()的结构(列表)指针而不是一个地址清单。
这些 addrinfo 结构随后可由套接接口函数直接使用。
如此一来，getaddrinfo 函数把协议相关性安全隐藏在这个库函数内部。
应用程序只要处理由 getaddrinfo 函数填写的套接字地址结构。
该函数在 POSIX 规范中定义了。
```

```
2、函数简单说明
host: 一个主机名或者地址串(IPv4的点分十进制或者IPv6的冒号分16进制)

service:服务名可以使十进制的端口号，也可以是已定义的服务名称。

hints:可以使一个空指针，也可以是一个纸箱某个 addrinfo 结构体的指针，调用者在这个结构中填入关于期望返回值的信息类型的暗示。
举例来说：如果指定的服务既支持TCP也支持UDP，那么调用者可以把hints结构中的ai_socktype成员设置成SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息。

result：本函数通过result指针参数返回一个指向addrinfo结构体链表的指针。

返回值：0——成功，非0——出错
```

```
3、参数设置
在getaddrinfo 函数之前通常需要对以下6个参数进行以下设置：hostname,servname,
hints的ai_flags,ai_family,ai_socktype,ai_protocol。

对函数影响最大的是 hostname,servname 和 hints.ai_falg。
而ai_family 只是有地址为 v4地址或 v6地址的区别。
ai_protocol 一般是为0。
protocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议，也可以填 0 让函数自己判定。

getaddrinfo 在实际使用中的几种常见参数设置
一般情况下，client/server编程中，server端调用bind（如果面向连接的还需要listen），client则不用掉bind函数，解析地址后直接connect（面向连接）或直接发送数据（无连接）。因此，比较常见的情况有
1、通常服务端在调用 getaddrinfo 之前，ai_flags 设置AI_PASSIVE，用于bind(),主机名 hostname 通常会设置为 null,返回通配地址[::]。
2、客户端调用getaddrinfo 时，ai_flags 一般不设置 AI_PASSIVE,但是主机名nodename和服务名servname（更愿意称之为端口）则应该不为空。
3、  当然，即使不设置AI_PASSIVE，取出的地址也并非不可以被bind，很多程序中ai_flags直接设置为0，即3个标志位都不设置，这种情况下只要hostname和servname设置的没有问题就可以正确bind。

上述情况只是简单的client/server中的使用，但实际在使用getaddrinfo和参考国外开源代码的时候，曾遇到一些将servname（即端口）设为NULL的情况(当然，此时nodename必不为NULL，否则调用getaddrinfo会报错)。

以下分情况进行了测试：
1、如果 hostname 是字符串型的IPv6地址，bind的时候会分配临时端口。
2、如果nodename是本机名，servname为NULL，则根据操作系统的不同略有不同，本文仅在WinXP和Win2003上作了测试。
        a)    WinXP系统（SP2）返回loopback地址[::1]
        b)    Win2003则将本机的所有IPv6地址列表加以返回。因为通常一台IPv6主机都有可能不止一个IPv6地址，比如fe80::1（本机 loopback地址）、fe80::***的Link-Local地址、3ffe:***的全局地址等等。这种情况下调用getaddrinfo会将这些地址全部返回，调用者应该注意如何使用这些地址。另外要注意的是，对于fe80::的地址在绑定的时候必须标明接口地址，即使用 fe80::20d:60ff:fe78:51c2%4或fe80::1%1这样的地址格式，通过getaddrinfo直接取出fe80地址好像无法直接bind。
```

```
4、使用细节
如果本函数返回成功，那么由result 参数指向的变量已被填入一个指针，它指向的是由其中的 ai_next 成员串联起来的 addrinfo 结构链表。
可以导致返回多个 addrinfo 结构的情形有以下2个：
1、如果与 hostname 参数关联的地址有多个，那么适用于所请求地址簇的每个地址都返回一个对应的结构。
2、如果service参数指定的服务支持多个套接字类型，那么每个套接字类型都可能返回一个对应的结构，具体取决于 hints 结构的 ai_socktype成员。
一个ip地址有可能返回下面三种套接字类型   SOCK_DGRAM    SOCK_SEQPACKET   SOCK_STREAM 。
```

![](images11-01/01-46.jpg)

```
typedef struct addrinfo {
int ai_flags;
int ai_family;
int ai_socktype;
int ai_protocol;
size_t ai_addrlen;
char* ai_canonname;
struct sockaddr* ai_addr;
struct addrinfo* ai_next;
} ai_addrlen must be zero or a null pointer
ai_canonname must be zero or a null pointer
ai_addr must be zero or a null pointer
ai_next must be zero or a null pointer
可以改动的参数
ai_flags:AI_PASSIVE,AI_CANONNAME,AI_NUMERICHOST
ai_family: AF_INET,AF_INET6
ai_socktype:SOCK_STREAM,SOCK_DGRAM
ai_protocol:IPPROTO_IP, IPPROTO_IPV4, IPPROTO_IPV6 etc.

3 参数说明
在getaddrinfo函数之前通常需要对以下6个参数进行以下设置：nodename、servname、hints的ai_flags、ai_family、ai_socktype、ai_protocol
在6项参数中，对函数影响最大的是nodename，sername和hints.ai_flag
而ai_family只是有地址为v4地址或v6地址的区别。而ai_protocol一般是为0不作改动。

其中ai_flags、ai_family、ai_socktype说明如下：
参数 取值 值 说明
ai_family AF_INET 2 IPv4
	AF_INET6 23 IPv6
	AF_UNSPEC 0 协议无关
ai_protocol IPPROTO_IP 0 IP协议
	IPPROTO_IPV4 4 IPv4 
	IPPROTO_IPV6 41 IPv6
	IPPROTO_UDP 17 UDP
	IPPROTO_TCP 6 TCP
ai_socktype SOCK_STREAM 1 流
	SOCK_DGRAM 2 数据报
ai_flags AI_PASSIVE 1 被动的，用于bind，通常用于server socket
AI_CANONNAME 2
AI_NUMERICHOST 4 地址为数字串
 
 
对于ai_flags值的说明：
AI_NUMERICHOST AI_CANONNAME AI_PASSIVE
0/1 0/1 0/1

如上表所示，ai_flags 的值返回为 0~7，取决于程序如何设置3个标志位，比如设置 ai_flags 为 "AI_PASSIVE|AI_CANONNAME",ai_flags值就为3。三个参数的含义分别为：
1、AI_PASSIVE 当此标记此标志位时，表示调用者将在 bind()函数调用中使用返回的地址结构。
当不标记此标志时，表示将在 connect()函数调用中使用。
当hostname为null，且标记 AI_PASSIVE 时，则返回的地址是 通配地址。
当hostname为null，且没有标记 AI_PASSIVE 时，则返回的地址是 回环地址。

2、AI_CANONAME 当标记此标志位时， 在函数所返回的第一个addrinfo 结构中的 ai_canonname 成员中，应该包含一个以空字符串结尾的字符串，字符串的内容是节点名的正规名(域名)。
3、AI_NUMBERCHOST 当此标志置位时，此标志表示调用中的hostname 必须是一个数字地址字符串。
```

**下面的是书里面讲的，上面是网络上的博客讲的**

```
给定 host 和 serveice(套接字地址的两个组成部分)，getaddrinfo 返回 result, result 一个指向 addrinfo 结构的链表，其中每个结构指向一个对应于 host 和 service 的套接字地址结构(图 11-15)。
```

![](images11-01/01-45.jpg)

```
在客户端调用了 getaddrinfo 之后，会遍历这个列表，依次尝试每个套接字地址，直到调用 socket 和 connect 成功，建立起连接。
类似地,服务器会尝试遍历列表中的每个套接字地址，直到调用 socket 和 bind 成功，描述符会被绑定到一个合法的套接字地址。
为了避免内存泄漏，应用程序必须在最后调用 freeaddrinfo，释放该链表。
如果 getaddrinfo 返回非零的错误代码，应用程序可以调用 gai_strerror,将该代码转化成消息字符串。
```

```
getaddrinfo 的 host 参数可以是域名，也可以是数字地址(如点分十进制 IP 地址)。
service 参数是服务名(如 http)，也可以是十进端口号。
如果不想把主机名转换成地址，可以吧host设置为 null。
当hostname为null，且标记 AI_PASSIVE 时，则返回的地址是 通配地址。
当hostname为null，且没有标记 AI_PASSIVE 时，则返回的地址是 回环地址。
对于service来说也是一样的。但是必须指定两者中至少一个。
service 操作系统会随机一个未使用的port来当做service。
```

```
可选的参数 hints 是一个 addrinfo 结构(见图11-16)，它提供对 getaddrinfo 返回的套接字地址列表的更好的控制。
如果要传递 hints 参数，只能设置以下字段：
ai_family、ai_socktype、ai_protocol和ai_flags 字段。
其他字段必须设置为 0(或者Null)。
实际中，我们用 memset 将整个结构清零，然后有选择的设置一些字段：
```

```
getaddrinfo 默认可以返回 IPv4 和 IPv6 套接字地址。
ai_family 设置为 AF_INET 会将列表限制为 IPv4 地址;
设置为 AF_INET6 则限制为 IPv6 地址。



对于 host 关联的每个地址，getaddrinfo 函数默认最多返回三个 addrinfo 结构，每个的 ai_socktype 字段不同：一个是连接，一个是数据报(本书为讲述 UDP)，一个是原始套接字(本书为讲述)。
注：这里的每个地址，指的是 比如 一个 192.0.0.2 地址有三个 addrinfo 结构，这些结构里面的 ip地址都是一样的，只是 ai_socktype 不一样。
ai_socktype 设置为 SOCK_STREAM 将列表限制为对每个地址最多一个 addrinfo 结构，该结构的套接字地址可以作为连接的一个端点。
这就是所有示例程序所期望的行为。



ai_flags 字段是一个位掩码，可以进一步修改默认行为。
可以吧各种值用 OR 组合起来得到该掩码。
下面是一些我们认为有用的值：
	AI_ADDRCONFIG。如果在使用连接，就推荐使用这个标志。它要求只有当本地主机被配置为 IPv4 时，getaddrinfo 返回IPv4地址。对 IPv6也是类似。
	AI_CANONNAME。ai_canoname 字段默认为 NULL。如果设置了该标志，就是告诉 getaddrinfo 将列表中第一个 addrinfo 结构的 ai_canonname 字段指向 host 权威(官方)名字(见图11-15)。
	AI_MUMBERICSERV。参数service默认可以是服务名或端口号。这个表示强制参数 service 为端口号。
	AI_PASSIVE。getaddrinfo 默认返回套接字地址，客户端可以在调用 connect 时用作主动套接字。
	这个标志告诉该函数，返回的套接字地址可能被服务器用做监听套接字。
	在这种情况中，参数 host 应该为 null。
	得到的套接字地址结构中的地址结构中的地址字段会是通配符地址(wildcard address)，告诉内核这个服务器会接受发送到该主机的所有IP地址的请求。
	这是所有示例服务器所期望的行为。
```

![](images11-01/01-47.jpg)

```
当 getaddrinfo 创建输出列表中的 addrinfo 结构中，会填写每个字段，除了 ai_flags。
ai_addr 字段指向一个套接字地址结构，ai_addrlen 字段给出这个套接字地址结构的大小，而ai_next 字段指向列表中下一个addrinfo 结构。
其他字段描述这个套接字地址的各种属性。
```

```
getaddrinfo 一个很好的方面是 addrinfo 结构中的字段是不透明的，即它们可以直接传递给套接字结构中的函数，应用程序代码无需再做任何处理。

例如，ai_famliy、ai_socktype 和 ai_protocol 可以直接传递给 socket。
类似地，ai_addr 和 ai)addrlen 可以直接传递给 connect 和 bind。
这个强大的属性使得我们编写的客户端和服务器能够独立于某个特殊版本的IP协议。
```



#### 2、getnameinfo

```
getnameinfo 函数 和 getaddrinfo 是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串。
它是已弃用的 gethostbyaddr 和 getservbyport 函数的新的替代品，和以前的那些函数不同，它是可重入和与协议无关的。
```

![](images11-01/01-48.jpg)

```
参数 sa 指向大小为salen 字节的套接字地址结构，host 指向大小为 hostlen 字节的缓冲区，service 指向大小为 servlen 字节的缓冲区。
getnameinfo 函数将套接字地址结构 sa 转换成对应的主机和服务名字符串，并将它们复制到 host 和 service 缓冲区。
如果 getnameinfo 返回非零的错误代码，应用程序可以调用 gai_strerror 把它转化成字符串。
```

```
如果不想要主机名，可以吧 host 设置为 Null,hostlen设置为 0。对服务字段来说也是一样的。
不过，两者必须设置其中之一。
参数 flags 是一个位掩码，能够修改默认的行为。
可以把各种值用 OR 组合起来得到该掩码。
下面是两个有用的值：
NI_NUMERICHOST：
getnameinfo 默认试图返回 host 中的域名。
设置该标志会使函数返回一个数字地址字符串。

NI_NUMERRICSERV：
getnameinfo 默认会检查 /etc/services，如果可能，会返回服务名而不是端口号。
设置该标志会使函数跳过查找，简单的返回端口号。
```

```
图11-17给出了一个简单的程序，程序 HOSTINFO,它使用 getaddrinfo 和 getnameinfo 展示出域名到和它相关联的IP地址之间的映射。
该程序类似于 11.3.2节中的 NSLOOKUP 程序。
```

![](images11-01/01-49.jpg)

```
首先，初始化 hints 结构，使 getaddrinfo 返回我们想要的地址。
在这里，我们想查找 32 位的 IP 地址(第16行)，用作连接的端点(第17行)。
因为只想 getaddrinfo 转换域名，所以用 service 参数为 NULL 来调用它。
```

```
调用 getaddrinfo 之后，会遍历 addrinfo 结构，用 getnameinfo 将每个套接字地址转换成点分十进制地址字符串。
遍历完列表之后，我们调用 freeaddrinfo 小心的释放这个列表。
```

![](images11-01/01-50.jpg)

























