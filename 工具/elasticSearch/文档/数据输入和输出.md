## 1、什么是文档

```
在大多数应用中，多数实体或对象可以被序列化为包含键值对的 JSON 对象。一个键可以是一个字段或字段的名称，
一个值可以是一个字符串，一个数字，一个布尔值，另一个对象，一些数组值，或一些其他特殊类型诸如表示日期的字符串，或代表一个地理位置的对象
```

```
通常情况下，我们使用的术语对象和文档是可以互相替换的。不过，有一个区别：一个对象仅仅是类似于 hash、hashMap、字典或者关联数组的 JSON 对象，对象中也可以嵌套其他的对象。对象可能包含了另外一些对象。在ElasticSearch 中，术语文档有着特定的含义。它是指最顶层或者根对象，这个跟对象被序列化成JSON并存储到ElasticSearch 中，指定了唯一ID.
```

## 2、文档元数据

```
一个文档不仅仅包含它的数据，也包含元数据 -- 有关文档的信息。三个必须的元数据元素如下：
_index 文档在哪存放
_type  文档表示的对象类别
_id    文档唯一标识
```

_index

```
一个索引应该是因共同的特性被分组到一起的文档集合。例如，你可能存储所有的产品在索引 products 中，而存储所有销售的交易到索引 sales 中。虽然也允许存储不相关的数据到一个索引中，但这通常看作是一个反模式的做法。
```

```
tip
	实际上，在 Elasticsearch 中，我们的数据时被存储和索引在 分片 中，而一个索引仅仅是逻辑上的命名空间，这个命名空间由一个或者多个分片组合在一起。然而，这是一个内部细节，我们的应用程序根本不应该关心分片，对于应用程序而言，只需要知道文档位于一个索引内。ElasticSearch 会处理所有的细节。
	
我们将在索引管理介绍如何自行创建和管理索引，但现在我们将让 ElasticSearch帮我们创建索引。所有需要我们做的就是选择一个索引名，这个名字必须小写，不能以下划线开头，不能包含逗号。
```

_type

```
数据可能在索引中只是松散的组合在一起，但是通常明确定义一些数据中的子分区是很有用的。例如，所有的产品都放在一个索引中，但是你有许多不同的产品类别。

这些文档共享一种相同的(或非常相似)的模式。

Elasticsearch 公开了一个称为 types (类型)的特性，他允许您在索引中对数据进行逻辑分区。不同types 的文档可能有不同的字段，但最好能够非常相似。

一个 _type 命名可以是大写或者小写，但是不能以下划线或者句号开头，不应该包含逗号，并且长度限制为256个字符。
```

_id

```
ID 是一个字符串，当它和 _index 以及 _type 组合就可以唯一确定 elasticsearch 种的一个文档。当你创建一个新的文档，要么提供自己的 _id,要么让 elasticsearch 帮你生成
```

其他元数据

```
还有一些其他的元数据，他们在类型和映射进行了介绍。通过前面已经列出的元数据元素，我们已经能存储文档到 Elasticsearch 中并通过 ID 检索它--换句话说，使用 Elasticsearch 作为文档的存储介质。
```

## 3、索引文档

```
通过使用 index API, 文档可以被索引 -- 存储和使用文档可被搜索。但是首先，我们要确定文档的位置。正如我们刚刚讨论的，一个文档的 _index、_type、_id 唯一标识一个文档。我们可以提供自定义的 _id 值，或者让 indeAPI 自动生成。
```

### 使用自定义的 ID 

```
如果你的文档有一个自然的标识符(例如，一个 user_account 字段或其他标识文档的值)，你应该使用如下方式的 indexAPI 并提供你自己的 _id  :
```

```
PUT /{index}/{type}/{id}
{
"field" : "value",
...
}
```

例子

```
PUT /website/blog/123
{
  "title": "My first blog entry",
  "text":  "Just trying this out...",
  "date":  "2014/01/01"
}

elasticsearch 响应体如下所示：
{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "123",
   "_version":  1,
   "created":   true
}

该响应表明文档已经成功创建，该索引包括 _index 、 _type 和 _id 元数据， 以及一个新元素： _version 。

在 elasticsearch 中每个文档都有一个版本号。当每次对文档进行修改时(包括删除)，_version 的值会递增。在处理冲突中，我们讨论了怎样使用 _version 号码确保你的应用程序中的一部分修改不会覆盖另一部分所做的修改。
```



### Autogenerating IDs

```
如果你的数据没有自然的 ID, elasticsearch 可以帮我们自动生成ID。请求的结构调整为： 不再使用 PUT 谓词(使用这个URL存储这个文档)，而是使用 POST 谓词
```

```
现在 URL 只需要包含 _index 和 _type

POST /website/blog/
{
  "title": "My second blog entry",
  "text":  "Still trying this out...",
  "date":  "2014/01/01"
}

除了 _id 是 elasticsearch 自动生成的，响应的其他部分和前面类似：
响应

{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "AVFgSgVHUP18jI2wRx0w",
   "_version":  1,
   "created":   true
}
```

```
自动生成的 ID 是 URL-safe、 基于 Base64 编码且长度为 20 个字符的 GUID 字符串。这些 GUID 字符串可修改的 FlakeID 模式生成，这种模式允许多个节点并行生成唯一 ID,且互相之间的冲突概率几乎为零。
```



## 4、取回一个文档

```
为了从 elasticsearch 中检索出文档，我们仍然使用相同的 _index, _type, _id , 但是 HTTP 谓词更改为 get 

GET /website/blog/123?pretty
```

```
响应体包括目前已经熟悉了的元数据元素，再加上 _source 字段，这个字段包括我们索引数据时发送给 elasticsearch 的原始 JSON 文档：

{
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 1,
  "found" :    true,
  "_source" :  {
      "title": "My first blog entry",
      "text":  "Just trying this out...",
      "date":  "2014/01/01"
  }
}
```

```
在请求的查询字符串参数中加上 pretty 参数，正如前面的例子中看到的，这将会调用 elasticsearch 的 pretty-print 功能，该功能使得 JSON 响应体更加可读。但是，_source 字段不能被格式化打印出来。相反，我们得到的 _source 子弹中的 JSON 串，刚好是和我们传给它的一样.

就是会将其格式化为 更加可读的形式
```



```
GET 请求的响应体包括 {"found":true}, 这证实了文档已经被找到。
如果我们请求一个不存在的文档，我们仍然会得到一个 JSON 响应体，但是 found 将会是 false. 此外， HTTP 响应码将会是 404 Not found, 而不是 200 OK


GET http://localhost:9200/website/blog/124?pretty

{
  "_index" : "website",
  "_type" :  "blog",
  "_id" :    "124",
  "found" :  false
}
```

### 返回文档的一部分

```
默认情况下， get 请求会返回整个文档，这个文档正如存储在 _source 字段中的一样。但是也许你只对其中的 title 字段感兴趣。单个字段能用 _source 参数请求得到，多个字段也能使用逗号分隔的列表来指定。

GET /website/blog/123?_source=title,text

该 _source 字段现在包含的只是我们请求的那些字段，并且已经将 date 字段过滤掉了。

{
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 1,
  "found" :   true,
  "_source" : {
      "title": "My first blog entry" ,
      "text":  "Just trying this out..."
  }
}
```

```
或者，如果你只想得到 _source 字段，不需要任何元数据，你能使用 _source 端点：

GET /website/blog/123/_source

{
   "title": "My first blog entry",
   "text":  "Just trying this out...",
   "date":  "2014/01/01"
}
```



## 5、检查文档是否存在

```
如果只想检查一个文档是否存在 —— 根本不想关心内容 --那么用 HEAD 方法来代替 GET 方法。 HEAD 请求没有返回体，只返回一个 HTTP 请求报头：

HEAD http://localhost:9200/website/blog/123

如果文档存在，Elasticsearch 将返回一个 200 ok 的状态码。

HTTP/1.1 200 OK
Content-Type: text/plain; charset=UTF-8
Content-Length: 0


若文档不存在， elasticsearch 将返回一个 404 Not Found 的状态码：

HTTP/1.1 404 Not Found
Content-Type: text/plain; charset=UTF-8
Content-Length: 0
```

当然，一个文档仅仅是在检查的时候不存在，并不意味着一毫秒之后它也不存在：也许同时正好另一个进程就创建了该文档。



## 6、更新整个文档

```
在 elasticsearch 中文档是 不可改变的，不能修改它们。相反，如果想要更新现有的文档，需要重建索引或者进行替换，我们可以使用相同的 indexAPI 进行实现。
```

```
PUT /website/blog/123
{
  "title": "My first blog entry",
  "text":  "I am starting to get the hang of this...",
  "date":  "2014/01/02"
}

在响应体中，我们能看到 Elasticsearch 已经增加了 _version 字段值：
{
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 2,
  "created":   false 
}

created 标志设置成 false ，是因为相同的索引、类型和 ID 的文档已经存在。
```

```
在内部，elasticsearch 已将旧文档标记为已删除，并增加一个全新的文档。尽管你不能再对旧版本的文档进行访问，但它并不会立即消失。当继续索引更多的数据， elasticsearch 会在后台清理这些已删除的文档。
```

```
在本章的后面部分，我们会介绍 update API，这个API 可以用于 partial updates to a document. 虽然它似乎对文档直接进行了修改，但实际上 elasticsearch 按前述完全相同方式执行以下过程：

1、从旧文档构建 JSON
2、更改该 JSON
3、删除旧文档
4、索引一个新文档

唯一的区别在于,  update API 仅仅通过一个客户端请求来实现这些步骤，而不需要单独的 get 和 index 请求。
```

## 7、创建新文档

```
当我们索引一个文档，怎么确认我们正在创建一个完全新的文档，而不是覆盖现有的呢？

请记住，_index _type _id 的组合可以唯一标识一个文档。所以，确保创建一个新文档的最简单办法就是，使用索引请求的 post 形式让 elasticsearch 自动生成唯一 _id：

POST /website/blog/
{ ... }
```

```
然而，如果已经有自己的 _id,那么我们必须告诉 elasticsearch，只有在相同的 _index _type _id 不存在时才接受我们的索引请求。这里有两种方式，他们做的实际是相同的事情。使用哪种，取决于哪种使用起来更方便。
```

```
第一种方法使用 op_type 查询 - 字符串参数：
PUT /website/blog/123?op_type=create
{ ... }

第二种是在 URL 末端使用 /_create 
PUT /website/blog/123/_create
{ ... }
```

```
如果创建新文档的请求成功执行， elasticsearch 会返回元数据和一个 201 created 的 HTTP 响应码。

另一方面，如果具有相同的 _index _type _id 的文档已经存在， elasticsearch  将会返回 409 conflict 响应码，以及如下的错误信息： 



{
   "error": {
      "root_cause": [
         {
            "type": "document_already_exists_exception",
            "reason": "[blog][123]: document already exists",
            "shard": "0",
            "index": "website"
         }
      ],
      "type": "document_already_exists_exception",
      "reason": "[blog][123]: document already exists",
      "shard": "0",
      "index": "website"
   },
   "status": 409
}
```



## 8、删除文档

```
删除文档的语法和我们所知道的规则相同，只是使用 DELETE 方法

DELETE /website/blog/123

如果找到该文档，elasticsearch  将要返回一个 200 OK 的HTTP 响应码，和一个类似以下结构的响应体。注意，字段  _version 值已经增加： 

{
  "found" :    true,
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 3
}

如果文档没有 找到，我们将得到 404 Not Found 的响应码和类似这样的响应体：
{
  "found" :    false,
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 4
}
```

```
即使文档不存在 (Found 是 false), _version 值仍然会增加。这是 elasticsearch 内部记录本的一部分，用来确保这些改变在跨多节点时以正确的顺序执行。
```

```
正如已经在 更新整个文档 中提到，删除文档不会立即将文档从磁盘中删除，只是将文档标记为已删除状态。随着你不断的索引更多的数据， elasticsearch 将会在后台清理标记为已删除的文档。
```



## 9、处理冲突



```
在数据库领域中，有两种方法通常被用来确保并发更新时变更不会丢失：

悲观并发控制
这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。 一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。


乐观并发控制
Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。 然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。 例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。
```

## 10、乐观并发控制

```
elasticsearch 是分布式的。当文档创建、更新或删除时，新版本的文档必须复制到集群中的其他节点。Elasticsearch 也是异步和并发的，这意味着这些复制请求被并行发送，并且到达目的地时也许 顺序是乱的 。 Elasticsearch 需要一种方法确保文档的旧版本不会覆盖新的版本。


当我们之前讨论 index ， GET 和 delete 请求时，我们指出每个文档都有一个 _version （版本）号，当文档被修改时版本号递增。 Elasticsearch 使用这个 _version 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。

我们可以利用 _version 号来确保 应用中相互冲突的变更不会导致数据丢失。我们通过指定想要修改文档的 version 号来达到这个目的。 如果该版本不是当前版本号，我们的请求将会失败。
```

```
1.7以后的 es 不用 version 了 而是使用 if_seq_no 和 if_primary_term 来控制版本

这里就不详细记录了
```

## 11、文档的部分更新



### 更新和冲突

```
在本节的介绍中，我们说明 检索 和 重建索引 步骤的间隔越小，变更冲突的机会越小。 但是它并不能完全消除冲突的可能性。 还是有可能在 update 设法重新索引之前，来自另一进程的请求修改了文档
```









1.7 的新特性

```
去除了 type 

1.7以后的 es 不用 version 了 而是使用 if_seq_no 和 if_primary_term 来控制版本

_mapping  去除了映射 type 7.x已经没有type的概念了。

```

